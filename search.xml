<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[iOS概念攻坚之路（六）：事件传递与响应]]></title>
    <url>%2F2019%2F06%2F14%2FiOS%E6%A6%82%E5%BF%B5%E6%94%BB%E5%9D%9A%E4%B9%8B%E8%B7%AF%2F%EF%BC%88%E5%85%AD%EF%BC%89%EF%BC%9A%E4%BA%8B%E4%BB%B6%E4%BC%A0%E9%80%92%E4%B8%8E%E5%93%8D%E5%BA%94%2F</url>
    <content type="text"><![CDATA[前言这篇文章主要想弄清楚事件（如触摸屏幕）产生后，系统是如何通知到你的 App，在 App 内部是如何进行传递，最终又是如何确定最终的响应者的。 这些肯定是有规则的，在 App 内部，一个事件会按照一个规则（视图层级关系）去遍历寻找这个事件的最佳响应者，但是这个响应者有可能不处理事件，那么它又需要沿着一定的规则（响应者链）去传递这个事件，如果最终都无人处理，那么将这个事件抛弃，也就是不处理。 事件先来看看什么是事件。 事件对应的对象为 UIEvent，它有一个属性为 type，是 EventType 类型，EventType 是一个枚举类型： 1234567public enum EventType : Int &#123; case touches // 触摸事件 case motion // 运动事件 case remoteControl // 远程控制事件 @available(iOS 9.0, *) case presses // 按压事件&#125; 所以 iOS 中的事件有四种： touch events（触摸事件） motion events（运动事件） remote-control events（远程控制事件） press events（按压事件） 1.触摸事件触摸事件就是我们的手指或者苹果的 Pencil（触笔）在屏幕中所引发的互动，比如轻点、长按、滑动等操作，是我们最常接触到的事件类型。触摸事件对象可以包含一个或多个触摸，并且每个触摸由 UITouch 对象表示。当触摸事件发生时，系统会将其沿着线路传递，找到适当的响应者并调用适当的方法，例如 touchedBegan:withEvent:。响应者对象会根据触摸来确定适当的方法。 触摸事件分为以下几类： 手势事件 长按手势（UILongPressGestureRecognizer） 拖动手势（UIPanGestureRecognizer） 捏合手势（UIPinchGestureRecognizer） 响应屏幕边缘手势（UIScreenEdgePanGestureRecognizer） 轻扫手势（UISwipeGestureRecognizer） 旋转手势（UIRotationGestureRecognizer） 点击手势（UITapGestureRecognizer） 自定义手势 点击 button 相关 触摸事件对应的对象为 UITouch。 2.运动事件iPhone 内置陀螺仪、加速器和磁力仪，可以感知手机的运动情况。iOS 提供了 Core Motion 框架来处理这些运动事件。根据这些内置硬件，运动事件大致分为三类： 陀螺仪相关：陀螺仪会测量设备绕 X-Y-Z 轴的自转速率、倾斜角度等。通过 Core Motion 提供的一些 API 可以获取到这些数据，并进行处理；通过系统可以通过内置陀螺仪获取设备的朝向，以此对 App UI 做出调整 加速器相关：设备可以通过内置加速器测量设备在 X-Y-Z 轴速度的改变；Core Motion 提供了高度计（CMAltimeter）、计步器（CMPedometer）等对象，来获取处理这些产生的数据 磁力仪相关：使用磁力仪可以获取当前设备的磁极、方向、经纬度等数据，这些数据多用于地图导航开发 不过官方文档中指出，这些都是属于 Core Motion 库框架，Core Motion 库中的事件直接由 Core Motion 内部进行处理，不会通过响应者链，所以 UIKit 框架能接收的事件暂时只包括摇一摇（EventSubtype.motionShake）。 3.远程控制事件远程控制事件允许响应者对象从外部附件或耳机接受命令，以便它可以管理音频和视频。目前 iOS 仅提供我们远程控制音频和视频的权限，即对音频实现暂停/播放、上一曲/下一曲、快进/快退操作。以下是它能识别的类型： 123456789101112public enum EventSubtype : Int &#123; case remoteControlPlay case remoteControlPause case remoteControlStop case remoteControlTogglePlayPause case remoteControlNextTrack case remoteControlPreviousTrack case remoteControlBeginSeekingBackward case remoteControlEndSeekingBackward case remoteControlBeginSeekingForward case remoteControlEndSeekingForward&#125; 4.按压事件iOS 9.0 之后提供了 3D Touch 事件，通过使用这个功能可以做如下操作： Quick Actions：重压 App icon 可以进行很多快捷操作 Peek and Pop：使用这个功能对文件进行预览和其他操作，可以在手机自带 “信息” 里面试验 Pressure Sensitivity：压力响应敏感，可以在备忘录中选择画笔，按压不同力度画出来的颜色深浅不一样 事件传递到 App 之前我们一般说的事件传递的起点在于 UIApplication 所管理的事件队列中开始分发的时候，但事件真正的起点在于你手指触摸到屏幕的那一刻开始（以触摸事件为例），那么在触摸屏幕到事件队列开始分发发生了什么？我们就以一个触摸事件来说明这个过程。 手指触摸屏幕，IOKit.framework 将事件封装成一个 IOHIDEvent 对象 将这个对象通过 mach port（IPC 进程间通信）转发到 Springboard Springboard 通过 mach port（IPC 进程间通信）转发给当前 App 的主线程 前台 App 主线程的 RunLoop 接收到 Springboard 转发过来的消息之后，触发对应的 mach port 的 Source1 回调 __IOHIDEventSystemClientQueueCallback() Source1 回调内部触发了 Source0 的回调 __UIApplicationHandleEventQueue() Source0 回调内部，封装 IOHIDEvent 为 UIEvent Source0 回调内部调用 UIApplication 的 +sendEvent: 方法，将 UIEvent 传给当前 UIWindow IOKit.framework 是一个系统框架的集合，用来驱动一些系统事件。IOHIDEvent 中的 HID 代表 Human Interface Device，即人机交互驱动 SpringBoard 是一个应用程序，用来管理 iOS 的主屏幕，除此之外像 WindowServer(窗口服务器)、bootstrapping(引导应用程序)，以及在启动时候系统的一些初始化设置都是由这个特定的应用程序负责的。它是我们 iOS 程序中，事件的第一个接收者。它只能接受少数的事件，比如：按键（锁屏/静音等）、触摸、加速、接近传感器等几种 Event，随后使用 mach port 转发给需要的 App 进程 UIApplication 管理了一个事件队列，之所以是队列而不是栈，是因为队列的特点是先进先出，先产生的事件先处理。UIApplication 会从事件队列中取出最前面的事件，并将事件分发下去以便处理，通常，先发送事件给应用程序的主窗口（keyWindow），主窗口会在视图层次结构中找到一个最合适的视图来处理触摸事件，这也是整个处理过程的第一步。 流程图（图1）： 事件传递UIWindow 接收到的事件，有的是通过响应者链传递，找到合适的响应者进行处理；有的不需要传递，直接用 first responder 来处理。这里我们主要说需要沿着响应者链传递的过程。 事件的传递大致可以分为三个阶段： Hit-Test（寻找合适的 view） Gesture Recognizer（手势识别） Response Chain（响应链，touch 事件传递） 通过手或触笔触摸屏幕所产生的事件，都是通过这三步去传递的，如前面提到的触摸事件和按压事件。 1.Hit-Test（寻找合适的 view）其实这是确定第一响应者的过程，第一响应者也就是作为首先响应此次事件的对象。对于每次事件发生之后，系统会去找能处理这个事件的第一响应者。根据不同的事件类型，第一响应者也不同： 触摸事件：被触摸的那个 view 按压事件：被聚焦按压的那个对象 摇晃事件：用户或者 UIKit 指定的那个对象 远程事件：用户或者 UIKit 指定的那个对象 菜单编辑事件：用户或者 UIKit 指定的那个对象 与加速计、陀螺仪、磁力仪相关的运动事件，是不遵循响应链机制传递的。Core Motion 会将事件直接传递给你所指定的第一响应者。 原理当点击一个 view，事件传递到 UIWindow 后，会去遍历 view 层级，直到找到合适的响应者来处理事件，这个过程也叫做 Hit-Test。 既然是遍历，就会有一定的顺序。系统会根据添加 view 的前后顺序，确定 view 在 subviews 中的顺序，然后根据这个顺序将视图层级转化为图层树，针对这个树，使用倒序、深度遍历的算法，进行遍历。之所以要倒叙，是因为最顶层的 view 最有可能成为响应者。 Hit-Test 在代码中对应的方法为： 123func hitTest(_ point: CGPoint, with event: UIEvent?) -&gt; UIView?// hitTest 内部调用下面这个方法func point(inside point: CGPoint, with event: UIEvent?) -&gt; Bool 详细步骤： keyWindow 接收到 UIApplication 传递过来的事件，首先判断自己能否接受触摸事件，如果能，那么判断触摸点在不在自己身上 如果触摸点在 keyWindow 身上，那么 keyWindow 会从后往前遍历自己的子控件（为了寻找最合适的 view） 遍历的每一个子控件都会重复上面的两个步骤（1.判断子控件是否能接受事件；2.触摸点在不在子控件上） 如此循环遍历子控件，直到找到最合适的 view，如果没有更合适的子控件，那么自己就是最合适的 view 每当手指接触屏幕，UIApplication 接收到手指的事件之后，就会去调用 UIWindow 的 hitTest:withEvent:，看看当前点击的点是不是在 window 内，如果是则继续依次调用 subView 的 hitTest:withEvent: 方法，直到找到最后需要的 view。调用结束并且 hit-test view 确定之后，这个 view 和 view 上面依附的手势，都会和一个 UITouch 的对象关联起来，这个 UITouch 会作为事件传递的参数之一，我们可以看到 UITouch 的头文件中有一个 view 和 gestureRecognizers 的属性，就是 hit-test view 和它的手势。 如下图（图2）： Hit-Test 是采用递归的方法从 view 层级的根节点开始遍历，来通过一个例子看一下它是如何工作的（图3）： UIWindow 有一个 MainView，MainView 里面有三个 subView：viewA、viewB、viewC。它们各自有两个 subView，它们的层级关系是：viewA 在最下面，viewB 在中间，viewC 最上（也就是 addSubview 的顺序，越晚 add 进去越在上面），其中 viewA 和 viewB 有一部分重叠。 如果手指在 viewB.1 和 viewA.2 重叠的方面点击，按照上面的递归方式，顺序如下图所示（图4）： 当点击图中位置时，会从 viewC 开始遍历，先判断点在不在 viewC 上，不在。转向 viewB，点在 viewB 上。转向 viewB.2，判断点在不在 viewB.2 上，不在。转向 viewB.1，点在 viewB.1 上，且 viewB.1 没有子视图了，那么 viewB.1 就是最合适的 view。遍历到这里也就结束了。 实现来看一下 hitTest:withEvent: 的实现原理，UIWindow 拿到事件之后，会先将事件传递给图层树中距离最靠近 UIWindow 那一层最后一个 view，然后调用其 hitTest:withEvent: 方法。注意这里是先将视图传递给 view，再调用其 hitTest:withEvent: 方法，并遵循以下原则： 如果 point 不在这个视图内，则去遍历其他视图 如果 point 在这个视图内，但是这个视图还有子视图，那么将事件传递给子视图，并且调用子视图的 hitTest:withEvent: 如果 point 在这个视图内，并且这个视图没有子视图，那么 return self，即它就是那个最合适的视图 如果 point 在这个视图内，并且这个视图没有子视图，但是不想作为处理事件的 view，那么可以 return nil，事件由父视图处理 另外， UIView 有些情况下是不能接受触摸事件的： 不允许交互：userInteractionEnabled = NO 隐藏：如果把父控件隐藏，那么子控件也会隐藏，隐藏的控件不能接受事件 透明度：如果设置一个控件的 alpha &lt; 0.01，会直接影响子控件的透明度。alpha 在 0 到 0.01 之间会被当成透明处理 注：如果父控件不能接受触摸事件，那么子控件就不可能接受到事件。 综上，我们可以得出 hitTest:withEvent: 方法的大致实现如下： 1234567891011121314151617override func hitTest(_ point: CGPoint, with event: UIEvent?) -&gt; UIView? &#123; // 是否能响应 touch 事件 if !isUserInteractionEnabled || isHidden || alpha &lt;= 0.01 &#123; return nil &#125; if self.point(inside: point, with: event) &#123; // 点击是否在 view 内 for subView in subviews.reversed() &#123; // 转坐标 let convertdPoint = subView.convert(point, from: self) // 递归调用，直到有返回值，否则返回 nil let hitTestView = subView.hitTest(convertdPoint, with: event) if hitTestView != nil &#123; return hitTestView! &#125; &#125; return self &#125; return nil&#125; 用一张图来表示 hitTest:withEvent: 的调用过程（图是 OC 语法）（图5）： 2.Gesture Recognizer（手势识别）确定了最合适的 view，接下来就是识别是何种事件，在触摸事件中，对应的就是何种手势。Gesture Recognizer（手势识别器）是系统封装的一些类，用来识别一系列常见的手势，例如点击、长按等。在上一步中确定了合适的 view 之后，UIWindow 会将 touches 事件先传递给 Gesture Recognizer，再传递给视图。可以自定义一个手势验证一下。 Gesture Recognizer 拥有的状态如下： 12345678910111213141516public enum State : Int &#123; // 尚未识别是何种手势操作（但可能已经触发了触摸事件），默认状态 case possible // 手势已经开始，此时已经被识别，但是这个过程中可能发生变化，手势操作尚未完成 case began // 手势状态发生改变 case changed // 手势识别完成（此时已经松开手指） case ended // 手势被取消，恢复到默认状态 case cancelled // 手势识别失败，恢复到默认状态 case failed // 手势识别完成，同 end public static var recognized: UIGestureRecognizer.State &#123; get &#125;&#125; Gesture Recognizer 有一套自己的 touches 方法和状态转换机制。一个手势总是以 possible 状态开始，表明它已经准备好开始处理事件。从该状态开始，开始识别各种手势，直到它们到达 ended、cancelled 或 failed 状态。手势识别器会保持在其中的一个最终状态，直到当前事件序列结束，此时 UIKit 重置手势识别器并将其返回 possible 状态。 再来看看触摸事件的类型： 长按手势（UILongPressGestureRecognizer） 拖动手势（UIPanGestureRecognizer） 捏合手势（UIPinchGestureRecognizer） 响应屏幕边缘手势（UIScreenEdgePanGestureRecognizer） 轻扫手势（UISwipeGestureRecognizer） 旋转手势（UIRotationGestureRecognizer） 点击手势（UITapGestureRecognizer） 苹果将手势识别器分为两种大类型，一个是离散型手势识别器（Discrete Gesture Recognizer），一个是连续型手势识别器（Continuous Gesture Recognizer）。离散型手势一旦识别就无法取消，而且只会调用一次操作事件，而连续型手势会多次调用操作事件，并且可以取消。在以上手势中，只有点击手势（UITapGestureRecognizer）属于离散型手势。 离散型手势识别示意图（图6）： 连续型手势识别的状态转换一般可分为三个阶段： 初始事件序列将手势识别器移动到 began 或 failed 状态 后续事件将手势识别器移动到 changed 或 cancelled 状态 最终事件将手势识别器移动到 ended 状态 如下图（图7）： Response Chain（响应链、touch 事件传递）识别出手势之后，就要确定由谁来响应这个事件了，最有机会处理事件的对象就是通过 Hit-Test 找到的视图或者第一响应者，如果两个都不能处理，就需要传递给下一位响应者，然后依次传递，该过程与 Hit-Test 过程正好相反。Hit-Test 过程是从上向下（从父视图到子视图）遍历，touch 事件处理传递是从下向上（从子视图到父视图）传递。下一位响应者是由响应者链决定的，那我们先来看看什么是响应者链。 Response Chain，响应链，一般我们称之为响应者链。在我们的 app 中，所有的视图都是按照一定的结构组织起来的，即树状层次结构，每个 view 都有自己的 superView，包括 controller 的 topmost view(即 controller 的 self.view)。当一个 view 被 add 到 superView 上的时候，它的 nextResponder 属性就会被指向它的 superView。当 controller 被初始化的时候，self.view(topmost view) 的 nextResponder 会被指向所在的 controller，而 controller 的 nextResponder 会被指向 self.view 的 superView，这样，整个 app 就通过 nextResponder 串成了一条链，这就是我们所说的响应者链。所以响应者链式一条虚拟的链，并没有一个对象来专门存储这样的一条链，而是通过 UIResponder 的属性串联起来的。 响应者链示意图（图8）： 即（右图）： 初始视图（initial view）尝试处理事件，如果不能处理，则将事件传递给其父视图（superView1） superView1 尝试处理事件，如果不能处理，传递给它所属的视图控制器（viewController1） viewController1 尝试处理事件，如果不能处理，传递给 superView1 的父视图（superView2） superView2 尝试处理事件，如果不能处理，传递给 superView2 所属的视图控制器（viewController2） viewController2 尝试处理事件，如果不能处理，传递给 UIWindow UIWindow 尝试处理事件，如果不能处理，传递给 UIApplication UIApplication 尝试处理事件，如果不能处理，抛弃该事件 再附一个苹果官方的图（图9）： UIResponder（响应者）在 iOS 中，只有继承于 UIResponder 的对象、或者它本身才能成为响应者。很多常见的对象都可以相应事件，比如 UIApplication 、UIViewController、所有的 UIView（包括 UIWindow）。 UIResponder 提供了以下方法来处理事件： 123456789101112131415161718192021// 触摸事件open func touchesBegan(_ touches: Set&lt;UITouch&gt;, with event: UIEvent?)open func touchesMoved(_ touches: Set&lt;UITouch&gt;, with event: UIEvent?)open func touchesEnded(_ touches: Set&lt;UITouch&gt;, with event: UIEvent?)open func touchesCancelled(_ touches: Set&lt;UITouch&gt;, with event: UIEvent?)@available(iOS 9.1, *)open func touchesEstimatedPropertiesUpdated(_ touches: Set&lt;UITouch&gt;)// 运动事件open func motionBegan(_ motion: UIEvent.EventSubtype, with event: UIEvent?)open func motionEnded(_ motion: UIEvent.EventSubtype, with event: UIEvent?)open func motionCancelled(_ motion: UIEvent.EventSubtype, with event: UIEvent?)// 远程控制事件open func remoteControlReceived(with event: UIEvent?)// 按压事件open func pressesBegan(_ presses: Set&lt;UIPress&gt;, with event: UIPressesEvent?)open func pressesChanged(_ presses: Set&lt;UIPress&gt;, with event: UIPressesEvent?)open func pressesEnded(_ presses: Set&lt;UIPress&gt;, with event: UIPressesEvent?)open func pressesCancelled(_ presses: Set&lt;UIPress&gt;, with event: UIPressesEvent?) 提供以下属性和方法来管理响应链： 123456789101112// 负责事件传递，默认返回 nil，子类必须实现此方法。open var next: UIResponder? &#123; get &#125;// 判断是否可以成为第一响应者open var canBecomeFirstResponder: Bool &#123; get &#125; // default is NO// 将对象设置为第一响应者open func becomeFirstResponder() -&gt; Bool // default is NO// 判断是否可以放弃第一响应者open var canResignFirstResponder: Bool &#123; get &#125; // default is YES// 放弃对象的第一响应者身份open func resignFirstResponder() -&gt; Bool // default is YES// 判断对象是否为第一响应者open var isFirstResponder: Bool &#123; get &#125; 补充一下 next：UIResponder 类并不自动保存或设置下一个响应者，该方法的默认实现是返回 nil。子类的实现必须重写这个方法来设置下一响应者。UIView 的实现是返回管理它的 UIViewController 对象（如果它有）或其父视图；UIViewController 的实现是返回它的视图（self.view）的父视图；UIWindow 的实现是返回 UIApplication 另外说一下 UITouch，对于触摸事件（对应的对象为 UITouch），系统提供了四个方法来处理： 123456open func touchesBegan(_ touches: Set&lt;UITouch&gt;, with event: UIEvent?)open func touchesMoved(_ touches: Set&lt;UITouch&gt;, with event: UIEvent?)open func touchesEnded(_ touches: Set&lt;UITouch&gt;, with event: UIEvent?)open func touchesCancelled(_ touches: Set&lt;UITouch&gt;, with event: UIEvent?)@available(iOS 9.1, *)open func touchesEstimatedPropertiesUpdated(_ touches: Set&lt;UITouch&gt;) 解释一下 touchesEstimatedPropertiesUpdated(_ touches: Set&lt;UITouch&gt;)，当无法获取真实的 touches 时，UIKit 会提供一个预估值，并设置到 UITouch 对应的 estimatedProperties 中监测更新。当收到新的属性更新时，会通过调用此方法来传递这些更新值。当使用 Apple Pencil 靠近屏幕边缘时，传感器无法感应到准确的值，此时会获取一个预估值赋给 estimatedProperties 属性。不断去更新数据，直到获取到准确的值。 上面的前四个方法，是由系统自动调用的： 默认情况下，当发生一个事件时，view 只接收到一个 UITouch 对象。当你使用多个手指同时触摸时，会接收多个 UITouch 对象，每个手指对应一个。多个手指分开触摸，会调用多次 touches 系列方法，每个 touches 里面有一个 UITouch 对象 如果你想处理一些额外的事件，可以重写以上四个方法，处理你想处理的事件。之后不要忘记调用 super.touchesxxx 方法，否则事件处理就中断于此，不会继续传递 来看一下 UITouch 对象，它保存了事件的相关信息： 12345678910111213141516171819202122232425// 触摸事件产生或变化的时间，单位是秒open var timestamp: TimeInterval &#123; get &#125;// 当前触摸事件所处的状态open var phase: UITouch.Phase &#123; get &#125;// 短时间内点按屏幕的次数open var tapCount: Int &#123; get &#125;// 触摸产生时所处的视图open var view: UIView? &#123; get &#125;// 触摸产生时所处的窗口open var window: UIWindow? &#123; get &#125;// 依附在 view 上的手势open var gestureRecognizers: [UIGestureRecognizer]? &#123; get &#125;// 使用硬件设备点击时，以点为圆心的 touch 半径，以此确定 touch 范围的大小open var majorRadius: CGFloat &#123; get &#125;// 半径公差open var majorRadiusTolerance: CGFloat &#123; get &#125;// 一些方法/**返回值表示触摸点在 view 上的位置调用时传入的 view 参数为 nil 的话，返回的是触摸点在 UIWindow 的位置*/open func location(in view: UIView?) -&gt; CGPoint// 记录了前一个触摸点的位置open func previousLocation(in view: UIView?) -&gt; CGPoint 实际运用以几个例子来说明事件传递与响应在项目中的运用，其实运用主要是围绕 hitTest:withEvent: 和 pointInside: 的使用，这里简单举个例子。 1.增加视图的 touch 区域在实际开发中，有些 button 面积很小，不容易点击上。这时候你想扩大 button 的响应区域，可以通过重写 hitTest:withEvent: 方法实现，如下图的情况（图10）： 实现代码： 1234567891011121314151617181920class MyButton: UIButton &#123; override func hitTest(_ point: CGPoint, with event: UIEvent?) -&gt; UIView? &#123; if !isUserInteractionEnabled || isHidden || alpha &lt;= 0.01 &#123; return nil &#125; let inset : CGFloat = 45 - 78 let touchRect = bounds.insetBy(dx: inset, dy: inset) if (touchRect.contains(point)) &#123; for subView in subviews.reversed() &#123; let convertdPoint = subView.convert(point, from: self) let hitTestView = subView.hitTest(convertdPoint, with: event) if hitTestView != nil &#123; return hitTestView! &#125; &#125; return self &#125; return nil &#125;&#125; 或者直接改 pointIndside 方法： 12345class MyButton: UIButton &#123; override func point(inside point: CGPoint, with event: UIEvent?) -&gt; Bool &#123; return bounds.insetBy(dx: 45-78, dy: 45-78).contains(point) &#125;&#125; 2.摇一摇事件之前没做过摇一摇，感觉还挺好玩的，就放在这里，其实很简单。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849import UIKitclass ShakeView : UIView &#123; override var canBecomeFirstResponder: Bool &#123; // 记得重写这个方法 return true &#125; override func motionBegan(_ motion: UIEvent.EventSubtype, with event: UIEvent?) &#123; if motion == .motionShake &#123; print("摇一摇") &#125; &#125; override func motionCancelled(_ motion: UIEvent.EventSubtype, with event: UIEvent?) &#123; if motion == .motionShake &#123; print("取消") &#125; &#125; override func motionEnded(_ motion: UIEvent.EventSubtype, with event: UIEvent?) &#123; if motion == .motionShake &#123; print("结束") &#125; &#125; &#125;class ViewController: UIViewController &#123; lazy var shakeView : ShakeView? = &#123; let shakeView = ShakeView(frame: view.bounds) shakeView.backgroundColor = #colorLiteral(red: 0.08779912442, green: 0.6471169591, blue: 0.9447124004, alpha: 1) return shakeView &#125;() override func viewDidLoad() &#123; super.viewDidLoad() // 设置支持摇一摇 UIApplication.shared.applicationSupportsShakeToEdit = true view.addSubview(shakeView!) shakeView?.becomeFirstResponder() &#125; &#125; 总结来个总结吧。 iOS 中的事件： 触摸事件 运动事件 远程控制事件 按压事件 事件从产生到系统传递到 App 的 keyWindow： 手指触摸屏幕，IOKit.framework 将事件封装成一个 IOHIDEvent 对象 将这个对象通过 mach port（IPC 进程间通信）转发到 Springboard Springboard 通过 mach port（IPC 进程间通信）转发给当前 App 的主线程 前台 App 主线程的 RunLoop 接收到 Springboard 转发过来的消息之后，触发对应的 mach port 的 Source1 回调 __IOHIDEventSystemClientQueueCallback() Source1 回调内部触发了 Source0 的回调 __UIApplicationHandleEventQueue() Source0 回调内部，封装 IOHIDEvent 为 UIEvent Source0 回调内部调用 UIApplication 的 +sendEvent: 方法，将 UIEvent 传给当前 UIWindow 事件传递分为三步： Hit-Test（寻找最合适的 view，即第一响应者） Gesture Recognizer（手势识别） Response Chain（响应链，传递 touch 事件） 1.Hit-Test： keyWindow 接收到 UIApplication 传递过来的事件，首先判断自己能否接受触摸事件，如果能，那么判断触摸点在不在自己身上 如果触摸点在 keyWindow 身上，那么 keyWindow 会倒序遍历自己的子控件 遍历的每一个子控件都会重复上面两个操作（1.判断子控件是否能接受事件；2.触摸点在不在子控件上） 如此循环遍历子控件，直到找到最合适的 view，如果没有，那么自己就是最合适的 view 可以看看图2。 2.Gesture Recognizer： UIWindow 会首先将 touches 事件传递给 Gesture Recognizer，再传递给视图。 触摸事件的具体类型有： 长按手势（UILongPressGestureRecognizer） 拖动手势（UIPanGestureRecognizer） 捏合手势（UIPinchGestureRecognizer） 响应屏幕边缘手势（UIScreenEdgePanGestureRecognizer） 轻扫手势（UISwipeGestureRecognizer） 旋转手势（UIRotationGestureRecognizer） 点击手势（UITapGestureRecognizer） 苹果又将手势识别器分为两大类型，离散型和连续型，上述类型中只有点击手势（UITapGestureRecognizer）属于离散型。 手势识别器拥有的状态： 12345678910111213141516public enum State : Int &#123; // 尚未识别是何种手势操作（但可能已经触发了触摸事件），默认状态 case possible // 手势已经开始，此时已经被识别，但是这个过程中可能发生变化，手势操作尚未完成 case began // 手势状态发生改变 case changed // 手势识别完成（此时已经松开手指） case ended // 手势被取消，恢复到默认状态 case cancelled // 手势识别失败，恢复到默认状态 case failed // 手势识别完成，同 end public static var recognized: UIGestureRecognizer.State &#123; get &#125;&#125; 3.Response Chain 事件沿着响应链传递，传递顺序与寻找第一响应者的顺序正好相反。 传递顺序： 初始视图（initial view）尝试处理事件，如果不能处理，则将事件传递给其父视图（superView1） superView1 尝试处理事件，如果不能处理，传递给它所属的视图控制器（viewController1） viewController1 尝试处理事件，如果不能处理，传递给 superView1 的父视图（superView2） superView2 尝试处理事件，如果不能处理，传递给 superView2 所属的视图控制器（viewController2） viewController2 尝试处理事件，如果不能处理，传递给 UIWindow UIWindow 尝试处理事件，如果不能处理，传递给 UIApplication UIApplication 尝试处理事件，如果不能处理，抛弃该事件 参考文章iOS 中的事件响应与处理 深入浅出iOS事件机制 你真的了解UIGestureRecognizer吗？ 官方文档 About the Gesture Recognizer State Machine 官方文档 Implementing a Discrete Gesture Recognizer 官方文档 Implementing a Continuous Gesture Recognizer 官方文档 Using Responders and the Responder Chain to Handle Events]]></content>
      <categories>
        <category>iOS概念攻坚之路</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>Objective-c</tag>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS概念攻坚之路（五）：线程同步方案]]></title>
    <url>%2F2019%2F06%2F11%2FiOS%E6%A6%82%E5%BF%B5%E6%94%BB%E5%9D%9A%E4%B9%8B%E8%B7%AF%2F%EF%BC%88%E4%BA%94%EF%BC%89%EF%BC%9A%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E6%96%B9%E6%A1%88%2F</url>
    <content type="text"><![CDATA[前言多线程编程所处的环境是一个复杂的环境，线程之间穿插执行，需要使用一定的手段来保证程序的正确运行，这个手段就是同步。这篇文章分了两个部分，第一部分会先介绍同步的概念，第二部分是 iOS 中能使用到的同步方案的一个分析以及具体如何使用。 线程同步的概念为什么要同步线程之间的关系是合作关系，既然是合作，那就得有某种约定的规则，否则合作就会出现问题。例如，第一个线程在执行了一些操作后想检查当前的错误状态 errno，但在其做出检查之前，线程 2 却修改了 errno。这样，当第一个线程再次获得控制权后，检查结果将是线程 2 改写过的 errno，而这是不正确的： 线程 1 线程 2 … … 读 errno 变量 … … 写 errno 变量 从读操作返回 … 检查 errno 值 … 之所以出现上述问题，是基于两个原因： errno 是线程之间共享的全局变量 线程之间的相对执行顺序是不确定的 解决上述问题有两个方法：第一个是限制全局变量，给每个线程一个私有的 errno 变量。事实上，如果可以将所有的资源都私有化，让线程之间不共享，那么这种问题就不复存在。 问题是，如果所有的资源都不共享，那么就不需要发明线程了，甚至也没必要发明进程。线程和进程的设计初衷：共享资源，提高资源利用率。所以这种方式是不切实际的。 那剩下的方法就是解决线程之间的执行顺序，方法就是同步。 同步的目的就是不管线程之间的执行如何穿插，都保证运行结果是正确的。 锁的进化：金鱼生存这个例子是《计算机的心智操作系统之哲学原理（第2版）》中举的例子，非常生动的描述了锁的由来。 养过金鱼的人都知道，金鱼有一个很大的特点，就是没有饱的感觉。因此，金鱼吃东西不会因为吃饱就停止。它们会不停的吃，直到胀死。因此，金鱼池多少得由养金鱼的人来确定，其死活也由人控制。 现在假定 A 和 B 两个人合住一套公寓，共同养了一条金鱼。该金鱼每天进食一次。两个人想把金鱼养活，一天只能喂一次，也只能喂一次。如果一天内两人都喂了鱼，鱼就胀死。如果一天内两人都没有喂鱼，鱼就饿死。 他们二人为了把鱼养好，既不让鱼胀死，也不让鱼饿死，做出如下约定： 每天喂鱼一次，且仅一次 如果今天 A 喂了鱼，B 几天就不能再喂；反之亦然 如果今天 A 没有喂鱼，B 今天就必须喂；反之亦然 显然，要想保持鱼活着，A 和 B 得进行某种合作。当然，最简单的情况是不进行任何沟通，每个人觉得需要喂鱼时，查看一下鱼的状态：如果感觉到鱼像是没进过食，则喂鱼；否则不喂。下图给出的是没有同步情况下 A 和 B 所执行的程序： 1234A: B:if (noFeed) &#123; if (noFeed) &#123; feed fish; feed fish;&#125; &#125; 那上述程序里是如何判断 noFedd 的值的呢？程序里没有给出，因此只能依靠 A 和 B 的高超养鱼技术，即通过查看鱼的外形来判断金鱼当天是否进食了。当然，只有高手才能达到这个水平，一般的人是看不出来的。万一 A 或者 B 没有看出对方已经喂过鱼了，再喂一次，鱼就胀死了。或者，没有看出对方没有喂过鱼，而没有喂，鱼就饿死了。 即使假设 A 和 B 都是养鱼高手，通过查看鱼的外形就可以判断鱼是否喂过，上述程序也能正确执行吗？答案是否定的。由于线程的执行可以任意穿插，A 可以先检查鱼，发现没有喂，就准备喂鱼。但就在 A 准备喂但尚未喂的时候，程序切换，轮到 B 执行。B 一看，鱼还没有喂（确实如此），就喂鱼。在喂完鱼后，线程再次切换到 A。此时 A 从检查完鱼状态后的指令开始执行，就是喂鱼。这样鱼被喂了两次，鱼就胀死了。 事件时序表 时序 A B 13:00 查看鱼(没喂) … 13:05 … 查看鱼(没喂) 13:10 … 喂鱼 13:25 喂鱼 … 鱼胀死 为什么这个程序会出现鱼胀死的情况呢？因为 A 和 B 两个人同时执行了同一段代码（if (noFeed) feed fish）。两个或多个线程争相执行同一段代码或访问同一资源的现象称为 竞争(race)。这个可能造成竞争的共享代码段或资源称为 临界区(critical section)。 当然，我们知道两个线程不可能真的在同一时刻执行（单核情况）。但有可能在同一时刻两个线程都在同一段代码上。这个例子里竞争的是代码，是代码竞争。如果是两个线程同时访问一个数据就叫做数据竞争。这个程序造成鱼胀死的就是因为两个线程同时进入了临界区。 以人类进化来说，此程序只相当与氨基酸阶段，胡乱竞争，并不具备任何协调能力。 变形虫阶段要防止鱼胀死，就需要防止竞争，要想避免竞争，就需要防止两个或多个线程同时进入临界区。要达到这一点，就需要某种协调手段。 协调的目的就是在任何时刻都只能有一个人在临界区里，这称为 互斥（mutual exclusion）。互斥就是说一次只有一个人使用共享资源，其他人皆排除在外。正确互斥需要满足 4 个条件： 不能有两个进程同时在临界区里面 进程能够在任何数量和速度的 CPU 上正确执行 在互斥区域外不能阻止另一个进程的运行 进程不能无限制的等待进入临界区 如果任何一个条件不满足，那么设计的互斥就是不正确的。 那么有没有办法确保一次只有一个人在临界区呢？有，让两个线程协调。当然，最简单的协调方法是交谈。问题是 A 和 B 不一定有时间碰面，那么剩下的办法是留纸条。由此，获得第一种同步方式：A 和 B 商定，每个人在喂鱼之前先留下字条，告诉对方自己将检查鱼缸并在需要时喂鱼： 12345678A: B:if (noNote) &#123; if (noNote) &#123; leave note; leave note; if (noFeed) &#123; if (noFeed) &#123; feed fish; feed fish; &#125; &#125; remove note; remove note;&#125; &#125; 上述机制能否避免鱼胀死呢？不能，如果 A 和 B 交叉执行上述程序，还是会造成鱼胀死的结局，这是因为虽然使用的是互斥的手段，即留字条，却没有达到互斥的目的。因为字条并没有方式 A 和 B 两个人同时进入临界区。当然，与第一个解决方案比起来，本方案还是有所改善，即鱼胀死的概率降低了。 只有在 A 和 B 严格交叉执行的情况下，才可能发生鱼胀死的现象。因此，我们并非完全在白费力气。 事件时序表 时序 A B 3:00 检查字条(没有) … 3:05 … 检查字条(没有) 3:10 … 留下字条 3:25 留下字条 … 3:50 查看鱼(没有喂过) … 4:05 … 查看鱼(没有喂过) 4:10 … 喂鱼 4:25 喂鱼 … 鱼胀死 此程序虽然加入了一点同步机制，但这个机制太原始，达不到真正的同步目的。以人类进化来比喻，此程序相当于变形虫阶段。 鱼阶段仔细分析可以发现，上述程序不解决问题的原因是我们先检查有没有字条，后留字条。这样在检查字条和留字条之间就留下了空当。那么我们就修改一下顺序，先留字条，再检查有没有对方的字条。如果没有对方的字条，那么就喂鱼，喂完把字条拿掉。不过这种方法需要区分字条是谁的，我们得到如下程序（第二种同步方案）： 12345678A: B:leave noteA; leave noteB;if (no noteB) &#123; if (no noteA) &#123; if (no feed) &#123; if (noFeed) &#123; feed fish; feed fish; &#125; &#125;&#125; &#125;remove noteA; remove noteB; 上述程序能够保证鱼不会被胀死，因为无论按照什么顺序穿插，总有一个人的留字条指令在另一个人的检查字条指令前执行，从而将防止两个人同时进入临界区，因而鱼不会因为两个人都喂而胀死。 但是，鱼却有可能饿死： 事件时序表 时序 A B 3:00 … 留字条 noteB 3:05 留字条 A 检查字条(没有) 3:10 检查字条 noteB(有) … 3:25 … 检查字条 noteA(有) 3:50 … 移除字条 noteB 4:05 移除字条 noteA … 没有人喂鱼，鱼饿死 虽然存在饿死的情况，但是我们的力气并没有白费。对于一个计算机系统来说，饿死好于胀死。如果胀死，则程序的运行很可能出错：几个线程同时获得同一个资源，出现不一致性及结果不确定性几乎是难以避免的。但如果是饿死，即大家都拿不到某个资源，线程处于饥饿状态，至多是停止推进，而这不一定产生错误结果，或许只是推迟结果的出现。 虽然饿死比胀死好受一点，但毕竟还是存在死的可能，还是在很原始的阶段。以人类进化来比，相当于鱼阶段。因此，我们需要继续进化，或者说努力。 猴阶段那么为什么鱼会饿死呢？是因为没有人进入临界区。虽然互斥确保了没有两个人同时进入临界区，但这种没有人进入临界区的情况则有点互斥过了头。要想鱼不饿死，还要保证有一个人进入临界区来喂鱼。那用什么办法来保证呢？ 办法就是让某个人等着，直到确认有人为了鱼才离去，不要一见到对方的字条就开溜走人。也就是说，在两个人同时留下字条的情况下，必须选择某个人来喂鱼，于是得出第 3 种同步方式： 1234567891011A: B:leave noteA; leave noteB;while(noteB) &#123; do nothing;&#125; if (no noteA) &#123;if (noFeed) &#123; if (noFeed) &#123; feed fish; feed fish;&#125; &#125; &#125;remove noteA; remove noteB; 鱼显然不会胀死，因为使用的办法包括了第 2 种同步方式。那么鱼会不会饿死呢？也不会，因为前面说过，鱼饿死的唯一情况是两个人同时留字条，并且又都走人。而上述程序在两个人都留字条的情况下，A 不会走人，而是一直循环等待直到对方删除字条后，再检查鱼有没有喂，并在没有喂的情况下喂鱼。因此，该同步方式既防止了胀死，又防止了饿死。 这一阶段算是猴阶段，鱼既不会胀死，也不会饿死，但这还不够。 锁猴阶段的同步机制虽然正确，但存在很多问题。 首先是程序不对称。A 执行的程序和 B 执行的程序并不一样。那不对称有什么问题吗？当然有，不对称造成程序编写困难，为了追求程序的正确性，即使是做同样操作的线程也得编写得不同，这自然就增加了编程的难度。不对称还造成程序证明的困难，要想从理论上证明第 3 种同步方式程序的正确性是一件十分复杂的事情，这一点研究程序证明的人是很清楚的。 上述程序的另一个大问题是浪费，A 执行的循环等待是一种很大的浪费，但浪费还不是循环等待的唯一问题，它还可能造成 CPU 调度的 优先级反转（倒挂）。优先级反转就是高优先级的线程等待低优先级的线程。例如，假如 B 先于 A 启动，留下字条后正准备检查是否有 A 的字条时，A 启动。由于 A 的优先级高于 B，因此 A 获得 CPU，留下字条，进入循环等待。由于 A 的优先级高，因此 B 无法获得 CPU 而完成剩下的工作，进而造成 A 始终处于循环等待阶段无法推进。这样高优先级的 A 就被低优先级的 B 所阻塞。由于优先级反转完全违反了设立优先级的初衷，所以令人无法容忍。 那我们只能对同步方案进行改进，那么在哪一个方案的基础上改进呢？我们自然会想到最后一个方案，因为它已经满足了鱼既不饿死也不胀死的条件，无非就是不好看和循环等待。关键是这两点可以改进吗？答案是否定的，循环等待不能去掉，一去掉就变成第 2 个方案；若想使其对称、美观，就需要将 B 改为和 A 同样，而这样同样会造成鱼饿死的可能。因此对最后一个方案进行修改似乎不是明智之举。 新的思路就是直接最开始的两个方案进行修改。由于最开始的两个方案均达不到既不饿死又不胀死的条件，因此我们自然选择一个较为美观、简单的方案来修改。在两个方案之间，第 1 个方案完全对称，而第 2 个方案不完全对称，因为每个人的字条不同。因此，我们选择第 1 个方案作为修改的基础。但如何修改呢？ 要想知道如何修改，就得知道第 1 个方案为什么不满足条件。 那么第 1 个方案为什么不满足条件呢？我们说过，是因为检查字条和留字条是两个步骤，中间留有被别的线程穿插的空当，从而造成字条作用的丧失。我们就想，能否将这两个步骤并为一个步骤，或者变成一个原子操作，使其中间不留空当，不就解决问题了吗？ 换句话说，我们之所以到现在还没把金鱼问题处理掉，是因为我们一直在非常低的层次上打转。因为我们试图工作的层面是鱼和鱼缸这个层面，即留字条是为了防止两个人同时查看鱼缸。我们仅仅在指令层上进行努力。由于控制的单元是一条条的指令，因此对指令之间的空当无能为力。而解决这种问题的办法就是提高抽象的层次，将控制的层面上升到对一组指令的控制。 例如，在金鱼问题里，如果我们将抽象层次从保护鱼和鱼缸的层次提高到保护放置鱼缸的房间的层次，这个问题就可以解决。这样，检查字条和留字条的两步操作就变成将房间锁上的一步操作。 那么如何保证这个房间一次只进入一个人呢？我们先看看生活当中我们是如何确保一个房间只能进入一个人的。例如，两个教师都想使用同一个教室来为学生补课，怎么协调呢？进到教室后将门锁上，另外一个教师就无法进来使用教室了。即教室是用锁来保证互斥的。那么在操作系统里，这种可以保证互斥的同步机制称为 锁。 有了锁，金鱼问题就可以解决了。当一个人进来想喂鱼时，就把放有鱼缸的房间锁住，这样另外一个人进不来，自然无法喂鱼，如下所示： 123456A: B:lock(); lock()if (noFeed) &#123; if (noFeed) &#123; feed fish; feed fish;&#125; &#125;unlock(); unlock(); 从上面程序我们可以看到，基于锁的互斥性，A 和 B 只能有一个人进入房间来喂鱼，因此鱼不会胀死。并且，如果两人都同时执行上述程序时，由于先拿到锁的人会进入房间喂鱼，因此鱼也不会饿死。更为重要的是，两个人执行完全同样的代码。既对称，也容易写，证明起来也不困难。这样，金鱼问题从而得到解决。 一个正常锁应该具备的特性： 锁的初始状态是打开状态 进临界区时必须获得锁 出临界区时必须打开锁 如果别人持有锁则必须等待 第一种方案之所谓没有将资源锁住，是因为违反了第 4 个条件，即在别人持有锁（留下字条）的情况下，也照样进入了临界区（因为检查是否别人持有锁在别人留锁之前进行）。因此，这个字条无法起到锁的作用。 以人类进化来比喻，上述程序相当于人阶段了。 那么这个程序还有什么问题没有？如果 A 正在喂鱼的话，B 能干什么事情吗？只能等待（等待锁变为打开状态）。如果 A 喂鱼的动作很慢，B 等待的事件就会很长。而这种繁忙等待不仅将造成浪费，而且将降低系统效率。那有没有办法消除锁的繁忙等待呢？答案是否定的，因为锁的特性就是在别人持有锁的情况下需要等待。不过还是可以减少繁忙等待的时间长度。怎么缩短等待的时间呢？ 仔细分析发现，A 喂鱼并不需要在持有锁的状态下进行。我们就希望喂鱼的这段时间不要放在锁里面，而是获得锁后留下字条说它喂鱼去了，然后释放锁，再喂鱼。而 B 在拿到锁后先检查有没有字条，有字条就释放锁，干别的去。没有就留字条，然后释放锁，再喂鱼。这样，由于持锁的时间只限于设置字条的事件，因此，对方循环等待的时间会很短，而真正的操作（在这里是喂鱼）则随便多慢也没有问题了。 123456789101112A: B:lock(); lock();if (no NoteB) &#123; if (no NoteA) &#123; leave noteA; leave noteB;&#125; &#125;unlock(); unlock();if (no NoteB) &#123; if (no NoteA) &#123; if (noFeed) &#123; if (noFeed) &#123; feed fish; feed fish; &#125; &#125; remove note; remove note;&#125; &#125; 这个方法使得锁上的繁忙等待时间变得很少。但不管怎样，终究还是需要等待的。那有没有办法不用进行任何繁忙等待呢？有，答案就是睡觉与叫醒，即 sleep 和 wakeup。 睡觉与叫醒：生产者与消费者问题什么是睡觉与唤醒呢？就是如果对方持有锁，你就不需要等待锁变为打开状态，而是去睡觉，锁打开后对方再来把你叫醒。我们下面用生产者与消费者的问题来演示这个机制。 生产者生产的产品由消费者来消费，但消费者一般不直接从生产者手里获取产品，而是通过一个中介机构，比如商店。生产者把东西放在这里，消费者到这里来拿。为什么需要这个中介机构呢？这是因为商店的存在使得生产者和消费者能够相对独立的运行，而不必亦步亦趋的跟在另一方后面。 用计算机来模拟生产者和消费者是件很简单的事：一个进程代表生产者，一个进程代表消费者，一片内存缓冲区代表商店。生产者生产的物品从一端放入缓冲区，消费者从另外一段获取物品，如下图： 一个非常好的例子是校园中的售货机。售货机是缓冲区，负责装载售货机的送货员是生产者，而购买可乐、糖果的学生是消费者。只要售货机不满也不空，送货员和学生就可以继续他们的送货和消费。问题是，如果学生来买可乐，却发现售货机空了，怎么办？学生当然有两个选择：一是坐在售货机前面等待，直到送货员来装货为止；二是回宿舍睡觉，等售货员装货后再来买。第 1 种方式显然效率很低，估计没有什么人愿意这么做。比较起来，第 2 种方式要好些。只不过睡觉中的学生不可能知道售货员来了，因此我们需要送货员来了后将学生叫醒。 同样，如果送货员来送货发现售货机满时也有两种应对办法：一是等有人来买走一些东西，然后将售货机填满；二是回家睡觉，等有人买了后再来补货。当然，这个时候购买者需要将送货员叫醒。以程序来表示生产者和消费者问题的解决方案如下： 1234567891011121314151617181920212223242526#define N 100 // 售货机最大商品数Int count = 0; // 售货机当前商品数void producer(void) &#123; int item; while(TRUE) &#123; item = produce_item(); if (count == N) sleep(); insert_item(item); count = count+1; if (count == 1) wakeup(consumer); &#125;&#125;void consumer(void) &#123; int item; while(TRUE) &#123; if (count == 0) sleep(); item = remove_item(); count = count-1; if (count == N-1) wakeup(producer); consume_item(item); &#125;&#125; sleep 和 wakeup 就是操作系统里的睡觉和叫醒操作原语。一个程序调用 sleep 后将进入休眠状态，将释放其所占用的 CPU。一个执行 wakeup 的程序将发送一个信号给指定的接收进程，如 wakeup(producer) 就发送一个信号给生产者。 我们仔细来看上面的程序。最上面两行定义了缓冲区的大小（可容纳 100 件商品）和当前缓冲区里面的商品个数，初始化为 0。生产者程序的运行如下：每生产一件商品，检查当前缓冲区的商品数，如果缓冲区已满，则该程序进入睡眠状态；否则将商品放入缓冲区，将计数加 1。然后判断计数是否等于 1 ，如果是，说明在放这件商品前缓冲区中的商品个数为 0，有可能存在消费者见到空缓冲区而去睡觉，因此需要发送叫醒信号给消费者。 消费者程序运行如下：先检查当前商品计数，如果是 0，没有商品，当然去睡觉。否则，从缓冲区拿走一件商品，将计数减 1 。然后判断计数是否等于 N-1。如果是，则说明在拿这件商品前缓冲区的商品计数为 N，有可能存在生产者见到满缓冲区而去睡觉，因此需要发送叫醒信号给生产者。然后尽情地享用商品。 这个程序看上去似乎正确无误，但实际上还是存在问题。 第一个问题：变量 count 没有被保护，可能发生数据竞争。即生产者和消费者可能同时对该数据进行修改。例如，假定 count 现在等于 1。那么生产者先运行，对 count 加 1 操作后 count 变为 2，但在判断 count 是否等于 1 之前，CPU 被消费者获得，随后对 count 进行了减 1 的操作后切换回生产者，这个时候 count 等于 1，因此生产者将发出叫醒消费者的信号。显然，这个信号是不应该发出的。 第二个问题：上述程序可能造成生产者和消费者均无法往前推进的情况，即死锁。例如，假定消费者先来，这个时候 count = 0，于是去睡觉，但是在判断 count == 0 后并且在执行 sleep 语句前 CPU 发生切换，生产者开始运行，它生产一件商品后，给 count 加 1，发现 count 结果为 1，因此发出叫醒消费者信号。但这个时候消费者还没有睡觉（正准备要睡），所以该信号没有任何效果，浪费了。而生产者一直运行直到缓冲区满了后也去睡觉。这个时候 CPU 切换到消费者，而消费者执行的第 1 个操作就是 sleep，即睡觉。至此，生产者和消费者都进入睡觉状态，从而无法相互叫醒而继续往前推进。系统死锁发生。 那我们如何解决上述两个问题呢？对第 1 个问题，解决方案很简单：用锁！在进行对 count 的操作前后分别加上开锁和闭锁即可防止生产者和消费者同时访问 count 情况的出现。不过，我们不就是因为锁存在繁忙等待才发明 sleep 和 wakeup 的吗？怎么又把锁请回来了呢？ 确实，我们不喜欢锁所采用的繁忙等待，因而发明了 sleep 和 wakeup，但是，我们不喜欢等待，并不是一刻都不能等，只要等待的事件够短，就是可以接受的。而在 count 的访问前后加上锁所造成的繁忙等待是很短的。（iOS SideTable 中的自旋锁也是这样的锁，因为引用计数的增减是很迅速的操作） 勉强解决了第 1 个问题，第 2 个问题怎么解决呢？ 显然，生产者和消费者都不会自己从睡觉中醒过来。所以如果二者同时去睡觉了，自然也无法叫醒对方。那解决的方案就是不让二者同时睡觉。而造成二者同时睡觉的原因是生产者发出的叫醒信号丢失（因为消费者此时还没睡觉）。那我们就想，如果用某种方法将发出的信号累积起来，而不是丢掉，问题不就解决了吗？在消费者获得 CPU 并执行 sleep 语句后，生产者在这之前发送的叫醒信号还保留，因此消费者将马上获得这个信号而醒过来。而能够将信号量累积起来的操作系统原语就是信号量。 信号量信号量(semphore) 可以说是所有原语里面功能最强大的。它不仅是一个同步原语，还是一个通信原语。而且，它还能作为锁来使用！前面已经讨论过作为通信原语的信号量，现在我们来看其作为同步原语和锁的能力。 简单来说，信号量就是一个计数器，其取值为当前累积的信号数量。它支持两个操作：加法操作 up 和减法操作 down，分别描述如下： down 减法操作： 判断信号量的取值是否大于等于 1 如果是，将信号量的值减去 1，继续往下执行 否则在该信号量上等待（线程被挂起） up 加法操作： 将信号量的值加 1（此操作将叫醒一个在该信号量上面等待的线程） 线程继续往下执行 这里需要注意的是，down 和 up 两个操作虽然包含多个步骤，但这些操作是一组原子操作，它们之间是不能分开的。 如果将信号量的取值限制为 0 和 1 两种情况，则获得的就是一把锁，也被称为 二元信号量（binary semaphore），其操作如下： down 减法操作： 等待信号量的值变为 1 将信号量的值设置为 0 继续往下执行 up 加法操作： 将信号量的值设置为 1 叫醒在该信号量上面等待的第 1 个线程 线程继续往下执行 由于二元信号量的取值只有 0 和 1，因此上述程序防止任何两个程序同时进入临界区。 二元信号量具备锁的功能，实际上它与锁很相似：down 就是获得锁，up 就是释放锁。但它又比锁更为灵活，因为在信号量上等待的线程不是繁忙等待，而是去睡觉，等待另外一个线程执行 up 操作来叫醒。因此，二元信号量从某种意义上说就是锁和睡觉与叫醒两种原语操作的合成。 有了信号量，我们就可以轻而易举地解决生产者和消费者的同步问题。具体说来就是，我们先设置 3 个信号量，分别如下： 1234567891011mutex:一个二元信号量，用来防止两个线程同时对缓冲区进行操作。初始值为 1。full:记录缓冲区里商品的件数。初始值为 0。empty:记录缓冲区里空置空间的数量。初始值为 N（缓冲区大小） 我们的生产者和消费者程序如下： 12345678910111213141516171819202122232425262728293031const int N = 100; // 定义缓冲区大小typedef int semaphore; // 定义信号量类型semaphore mutex = 1; // 互斥信号量semaphore empty = N; // 缓冲区计数信号量，用来计数缓冲区里的空位数量semaphore full = 0; // 缓冲区计数信号量，用来计数缓冲区里的商品数量void producer(void) &#123; int item; while(TRUE) &#123; item = produce_item(); down(empty); down(mutex); insert_item(item); up(mutex); up(full); &#125;&#125;void consumer(void) &#123; int item; while(TRUE) &#123; down(full); down(mutex); item = remove_item(); up(mutex); up(empty); consume_item(item); &#125;&#125; 该程序解决了前一个版本的问题吗？很显然，上述程序中生产者和消费者不可能同时睡觉而造成死锁。因为两个人同时睡觉就意味着：full=0（生产者才睡觉），并且 empty=0（消费者睡觉的条件）。那么 empty 和 full 能够同时为 0 吗？当然不会，因为初始值是 empty = N 而 full = 0。要使 empty=0，生产者就必须生产，而一旦生产者开始生产，full 就不能为 0 了。所以两个不会同时睡觉。 这样上述程序既保护了缓冲区不会被生产者和消费者同时访问，又防止了生产者或消费者发送的信号丢失。生产者生产了多少商品，信号量 full 就取多大的值，这就相当于前一个版本里面发送的信号的个数。因为消费者等待的地方就是 full 这个信号量，因此，生产者生产了多少商品，就可以最多这么多次叫醒消费者。反之亦然，消费者消费了多少商品，信号量 empty 就记录了多少数量，也就是可以多少次叫醒生产者。这样就解决了信号丢失的问题。 那为什么需要 3 个信号量呢？一个二元信号量用来互斥，一个信号量用来记录缓冲区里商品的数量不就可以了吗？缓冲区里空格的数量不是可以由缓冲区大小和缓冲区里商品的数量计算得出吗？为什么需要一个 full 和一个 empty 来记录满的和空的呢？这是因为生产者和消费者等待的信号不同，它们需要在不同的信号上睡觉。 iOS 线程同步方案先列举一下上面提到的概念： 同步：解决线程之间的执行顺序，不管线程之间的执行如何穿插，都保证运行结果是正确的 竞争：两个或多个线程争相执行同一段代码或访问同一资源的现象称为竞争 临界区：造成竞争的共享代码或资源 互斥：一次只有一个人使用共享资源，其他人皆排除在外 锁：一种操作系统中保持互斥的同步机制 优先级反转（倒挂）：高优先级的线程被低优先级线程阻塞 睡觉与叫醒（sleep 和 wakeup）：睡觉指让线程休眠，不占用 CPU 资源，叫醒指唤醒线程；为解决繁忙等待问题而被提出的方案 信号量：一个计数器，其取值为当前累积的信号数量；为解决信号丢失提出的方案 down 操作 判断信号量的值是否大于等于1 如果是，将信号量的值减 1，继续往下执行 否则在该信号量上等待（线程被挂起） up 操作 将信号量的值加 1（此操作将叫醒一个在该信号量上面等待的线程） 线程继续往下执行 二元信号量（互斥量）：信号量取值限制为 0 和 1，相当于锁和睡觉与叫醒操作的一个合成 iOS 中的线程同步方案，其实是 iOS 对锁、信号量、互斥量、条件变量的实现。因为 iOS 中使用了 GCD，所以还可以使用 GCD 的串行队列来实现同步。iOS 中有原子操作，就是在属性中使用 atomic，但是它有局限性，只能保证在设置和获取时是原子操作，但不能保证设置和获取操作是在哪一个线程中进行，下面先列举一下 iOS 中的那些线程同步方案： OSSpinLock os_unfair_lock pthread_mutex PTHREAD_MUTEX_NORMAL PTHREAD_MUTEX_ERRORCHECK PTHREAD_MUTEX_RECURSIVE PTHREAD_MUTEX_DEFAULT dispatch_semaphore dispatch_queue(DISPATCH_QUEUE_SERIAL) NSLock NSRecursiveLock NSCondition NSConditionLock @synchronized 来分别看一下它们的具体含义与如何使用，在下面的例子中我们统一使用下面这个异步方法： 12345678- (void)doSomeThingForFlag:(NSInteger)flag finish:(void(^)(void))finish &#123; dispatch_async(dispatch_get_global_queue(0, 0), ^&#123; NSLog(@"do:%ld",(long)flag); sleep(2+arc4random_uniform(4)); NSLog(@"finish:%ld",flag); if (finish) finish(); &#125;);&#125; OSSpinLockOSSPinlock 就是自旋锁，速度应该是最快的锁，等待锁的线程会处于 忙等（busy-wait） 状态，一直占用着 CPU 资源，因为它需要不断的去尝试获取锁。这种忙等状态的锁会造成一个很严重的问题，那就是优先级反转，也称为优先级倒挂，前面的猴阶段中也提到这个问题，另外 YYKit 的作者专门写了一篇 不再安全的 OSSpinLock 来解释这个问题： 在 iOS 中，系统维护了 5 个不同的线程优先级/Qos：background、utility、default、user-initiated、user-interactive。高优先级线程始终会在低优先级线程前执行，一个线程不会受到比它更低优先级线程的干扰。这种线程调度算法存在潜在的优先级反转的问题。 具体来说，在使用自旋锁的情况，如果一个低优先级的线程获得锁并访问共享资源，这时一个高优先级的线程也尝试获得这个锁，它会处于忙等状态状态从而占用大量 CPU。此时低优先级线程无法与高优先级线程争夺 CPU 时间（抢不过），从而导致任务迟迟完不成，无法释放 lock。这并不只是理论上的问题，lobobjc 已经遇到很多次这个问题，于是苹果的工程师停用了 OSSpinLock。 不过还是有解决方案，也是 libobjc 目前正在使用的：锁的持有者把线程 ID 保存到锁内部，锁的等待着会临时贡献出它的优先级来避免优先级反转的问题。理论上这种模式会在比较复杂的多锁条件下产生问题，但实践上目前还一切都好。 libobjc 里用的是 Mach 内核的 thread_switch() 然后传递了一个 mach thread port 来避免优先级反转，另外它还用了一个私有的参数选项，所以开发者无法自己实现这个锁。另一方面，由于二进制兼容问题，OSSpinLock 也不能有改动。 所以，除非开发者能保证访问锁的线程全部都处于同一优先级，否则 iOS 系统中所有类型的自旋锁都不能再使用了。当然苹果还在用，SideTable 中就包含了一个自旋锁，用于对引用计数的增减操作，这种轻量操作也是自旋锁的使用场景。 来看一下 OSSpinLock 的使用，要导入 &lt;libkern/OSAtomic.h&gt;： 123456789101112131415161718192021222324252627282930#import &lt;libkern/OSAtomic.h&gt;/** OSSpinLock */- (void)useOSSpinlock &#123; __block OSSpinLock oslock = OS_SPINLOCK_INIT; OSSpinLockLock(&amp;oslock); [self doSomeThingForFlag:1 finish:^&#123; OSSpinLockUnlock(&amp;oslock); &#125;]; OSSpinLockLock(&amp;oslock); [self doSomeThingForFlag:2 finish:^&#123; OSSpinLockUnlock(&amp;oslock); &#125;]; OSSpinLockLock(&amp;oslock); [self doSomeThingForFlag:3 finish:^&#123; OSSpinLockUnlock(&amp;oslock); &#125;]; OSSpinLockLock(&amp;oslock); [self doSomeThingForFlag:4 finish:^&#123; OSSpinLockUnlock(&amp;oslock); &#125;]; &#125; os_unfair_lockos_unfair_lock 是作为 OSSpinLock 的替代方案被提出来的，iOS 10.0 之后开始支持。不过从底层调用来看，等待 os_unfair_lock 的线程会处于休眠状态，而并非 OSSpinLock 的忙等状态，线程的切换是需要资源的，所以它的效率不如 OSSpinLock。 它的使用与 OSSpinLock 很类似： 123456789101112131415161718192021222324252627282930313233343536373839#import &lt;os/lock.h&gt;- (void)viewDidLoad &#123; [super viewDidLoad]; [self useOS_Unfair_Lock];&#125;// 定义锁变量os_unfair_lock unfairLock;- (void)useOS_Unfair_Lock &#123; // 初始化锁 unfairLock = OS_UNFAIR_LOCK_INIT; NSThread *thread1 = [[NSThread alloc] initWithTarget:self selector:@selector(request1) object:nil]; [thread1 start]; NSThread *thread2 = [[NSThread alloc] initWithTarget:self selector:@selector(request2) object:nil]; [thread2 start];&#125;- (void)request1 &#123; // 加锁 os_unfair_lock_lock(&amp;unfairLock); NSLog(@"do:1"); sleep(2+arc4random_uniform(4)); NSLog(@"finish:1"); // 解锁 os_unfair_lock_unlock(&amp;unfairLock);&#125;- (void)request2 &#123; // 加锁 os_unfair_lock_lock(&amp;unfairLock); NSLog(@"do:2"); sleep(2+arc4random_uniform(4)); NSLog(@"finish:2"); // 解锁 os_unfair_lock_unlock(&amp;unfairLock);&#125; pthread_mutexpthread_mutex 有几种类型： 1234567/* * Mutex type attributes */#define PTHREAD_MUTEX_NORMAL 0#define PTHREAD_MUTEX_ERRORCHECK 1#define PTHREAD_MUTEX_RECURSIVE 2#define PTHREAD_MUTEX_DEFAULT PTHREAD_MUTEX_NORMAL PTHREAD_MUTEX_NORMAL 是缺省类型，所以只有三种类型。 PTHREAD_MUTEX_NORMAL：默认类型，普通锁，当一个线程加锁后，其余请求锁的线程将形成一个等待队列，并在解锁后按优先级获得锁。这种锁策略保证了资源分配的公平性。 PTHREAD_MUTEX_ERRORCHECK：检错锁，如果同一个线程请求同一个锁，则抛出一个错误，否则与 PTHREAD_MUTEX_NORMAL 类型动作一致。这样就保证当不允许多次加锁时不会出现最简单情况下的死锁。 PTHREAD_MUTEX_RECURSIVE：递归锁，允许同一个线程对同一个锁成功获得多次，并通过多次 unlock 解锁。如果是不同线程请求，则在加锁线程解锁时重新竞争。 PTHREAD_MUTEX_NORMAL 的使用： 123456789101112131415161718192021222324252627282930313233343536373839404142#import &lt;pthread.h&gt;- (void)viewDidLoad &#123; [super viewDidLoad]; [self usePthread_mutex_normal];&#125;pthread_mutex_t pNormalLock;- (void)usePthread_mutex_normal &#123; // 初始化锁的属性 pthread_mutexattr_t attr; pthread_mutexattr_init(&amp;attr); pthread_mutexattr_settype(&amp;attr, PTHREAD_MUTEX_NORMAL); // 初始化锁 pthread_mutex_init(&amp;pNormalLock, &amp;attr); // 销毁 attr pthread_mutexattr_destroy(&amp;attr); pthread_mutex_lock(&amp;pNormalLock); [self doSomeThingForFlag:1 finish:^&#123; pthread_mutex_unlock(&amp;pNormalLock); &#125;]; pthread_mutex_lock(&amp;pNormalLock); [self doSomeThingForFlag:2 finish:^&#123; pthread_mutex_unlock(&amp;pNormalLock); &#125;]; pthread_mutex_lock(&amp;pNormalLock); [self doSomeThingForFlag:3 finish:^&#123; pthread_mutex_unlock(&amp;pNormalLock); &#125;]; pthread_mutex_lock(&amp;pNormalLock); [self doSomeThingForFlag:4 finish:^&#123; pthread_mutex_unlock(&amp;pNormalLock); &#125;]; &#125; PTHREAD_MUTEX_ERRORCHECK 与 PTHREAD_MUTEX_NORMAL 只是多了个同线程对同一把锁加锁的话会抛出一个错误，我们来看一下递归锁。递归锁意思是同一个线程可以多次获得同一个锁，其他线程如果想要获取这把锁，必须要等待，这种锁一般都是用于递归函数的情况。 递归锁的使用： 123456789101112131415161718192021222324252627282930313233343536373839404142#import &lt;pthread.h&gt;- (void)viewDidLoad &#123; [super viewDidLoad]; [self usePthread_mutex_recursive];&#125;pthread_mutex_t pRecursiveLock;- (void)usePthread_mutex_recursive &#123; // 初始化锁属性 pthread_mutexattr_t attr; pthread_mutexattr_init(&amp;attr); pthread_mutexattr_settype(&amp;attr, PTHREAD_MUTEX_RECURSIVE); // 初始化锁 pthread_mutex_init(&amp;pRecursiveLock, &amp;attr); // 销毁attr pthread_mutexattr_destroy(&amp;attr); [self thread1]; &#125;- (void)thread1 &#123; pthread_mutex_lock(&amp;pRecursiveLock); static int count = 0; count ++; if (count &lt; 10) &#123; NSLog(@"do:%d",count); [self thread1]; &#125; pthread_mutex_unlock(&amp;pRecursiveLock); NSLog(@"finish:%d",count);&#125;- (void)dealloc &#123; // 销毁锁 pthread_mutex_destroy(&amp;pRecursiveLock);&#125;@end dispatch_semaphoredispatch_semaphore 是 GCD 实现的信号量，信号量是基于计数器的一种多线程同步机制，内部有一个可以原子递增或递减的值，关于信号量的 API 主要是三个，create、wait 和 signal。 信号量在初始化时要指定 value，随后内部将这个 value 存储起来。实际操作会存在两个 value，一个是当前的 value，一个是记录初始 value。 信号的 wait 和 signal 是互逆的两个操作。如果 value 大于 0，前者将 value 减一，此时如果 value 小于 0 就一直等待。后者将 value 加一。 初始 value 必须大于等于 0，如果为 0 并随后调用 wait 方法，线程将被阻塞直到别的线程调用了 signal 方法。 简单来讲，信号量为 0 则阻塞线程，大于 0 则不会阻塞，可以通过改变信号量的值，来控制是否阻塞线程，从而达到线程同步。 12345678910// 创建信号量，参数：信号量的初始值，如果小于 0 会返回 NULLdispatch_semaphore_t dispatch_semaphore_create(long value);// 等待降低信号量，接收一个信号和时间值（多为 DISPATCH_TIME_FOREVER）// 若信号的信号量为 0，则会阻塞当前线程，直到信号量大于 0 或者经过输入的时间值// 若信号量大于 0，则会使信号量减 1 并返回，程序继续往下执行long dispatch_semaphore_wait(dispatch_semaphore_t dsema, dispatch_time_t timeout);// 增加信号量，使信号量加 1 并返回long dispatch_semaphore_signal(dispatch_semaphore_t dsema); 在 dispatch_semaphore_wait 和 dispatch_semaphore_signal 这两个函数中间的执行代码，每次只会允许限定数量的线程进入。我们一般需要控制线程数量的时候使用信号量，下面介绍信号量的几个使用场景。 保持线程同步，将异步操作转换为同步操作12345678910111213141516/** 保持线程同步，将异步操作转换为同步操作 */- (void)semaphoreTest1 &#123; dispatch_queue_t queue = dispatch_get_global_queue(0, 0); dispatch_semaphore_t semaphore = dispatch_semaphore_create(0); __block int i = 0; dispatch_async(queue, ^&#123; i = 100; dispatch_semaphore_signal(semaphore); &#125;); dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER); NSLog(@"i = %d",i);&#125; 结果输出 i = 100。block 异步执行添加到了全局并发队列里，所以程序在主线程会跳过 block 块（同时开辟子线程异步执行 block），执行 block 外的代码 dispatch_semaphore_wait，因为 semaphore 信号量为 0，且时间为 DISPATCH_TIME_FOREVER，所以会阻塞当前线程（主线程），进而只执行子线程的 block，直到 block 内部的 dispatch_semaphore_signal 使得信号量 +1。正在被阻塞的线程（主线程）会恢复继续执行，这样就保证了线程之间的同步。 为线程加锁12345678910111213141516171819202122232425262728/** 为线程加锁 */- (void)semaphoreTest2 &#123; dispatch_semaphore_t semaphore = dispatch_semaphore_create(1); dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER); [self doSomeThingForFlag:1 finish:^&#123; dispatch_semaphore_signal(semaphore); &#125;]; dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER); [self doSomeThingForFlag:2 finish:^&#123; dispatch_semaphore_signal(semaphore); &#125;]; dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER); [self doSomeThingForFlag:3 finish:^&#123; dispatch_semaphore_signal(semaphore); &#125;]; dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER); [self doSomeThingForFlag:4 finish:^&#123; dispatch_semaphore_signal(semaphore); &#125;]; &#125; 限制线程最大并发数1234567891011121314151617/** 限制线程最大并发数 */- (void)semaphoreTest3 &#123; dispatch_semaphore_t semaphore = dispatch_semaphore_create(3); dispatch_queue_t queue = dispatch_get_global_queue(0, 0); for (int i = 0; i &lt; 100; i++) &#123; dispatch_async(queue, ^&#123; dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER); NSLog(@"running"); sleep(1); NSLog(@"completed..................."); dispatch_semaphore_signal(semaphore); &#125;); &#125;&#125; 看控制台打印可以看到线程的最大并发数被限制在了 3。不过更好的做法是使用 NSOperationQueue 和 NSOperation 来实现，而不是通过 GCD 和信号量来构建自己的解决方案。 dispatch_queue(DISPATCH_QUEUE_SERIAL)123456789101112- (void)dispatch_queue_serial &#123; dispatch_queue_t queue = dispatch_queue_create("myQueue", DISPATCH_QUEUE_SERIAL); for (NSInteger i = 0; i &lt; 100; i++) &#123; dispatch_async(queue, ^&#123; dispatch_suspend(queue); [self doSomeThingForFlag:i finish:^&#123; dispatch_resume(queue); &#125;]; &#125;); &#125;&#125; 关键是使用 dispatch_suspend() 和 dispatch_resume()。 既然 GCD 可以实现，那么封装了 GCD 的 NSOperationQueue 自然也能够实现。 123456789101112131415161718192021222324252627282930313233343536373839404142434445- (void)userOperationQueue &#123; NSOperationQueue *queue = [[NSOperationQueue alloc] init]; [queue setMaxConcurrentOperationCount:1]; __weak typeof(self) weakSekf = self; NSBlockOperation *operation1 = [NSBlockOperation blockOperationWithBlock:^&#123; [queue setSuspended:YES]; [weakSekf doSomeThingForFlag:1 finish:^&#123; [queue setSuspended:NO]; &#125;]; &#125;]; NSBlockOperation *operation2 = [NSBlockOperation blockOperationWithBlock:^&#123; [queue setSuspended:YES]; [weakSekf doSomeThingForFlag:2 finish:^&#123; [queue setSuspended:NO]; &#125;]; &#125;]; NSBlockOperation *operation3 = [NSBlockOperation blockOperationWithBlock:^&#123; [queue setSuspended:YES]; [weakSekf doSomeThingForFlag:3 finish:^&#123; [queue setSuspended:NO]; &#125;]; &#125;]; NSBlockOperation *operation4 = [NSBlockOperation blockOperationWithBlock:^&#123; [queue setSuspended:YES]; [weakSekf doSomeThingForFlag:4 finish:^&#123; [queue setSuspended:NO]; &#125;]; &#125;]; [operation4 addDependency:operation3]; [operation3 addDependency:operation2]; [operation2 addDependency:operation1]; [queue addOperation:operation1]; [queue addOperation:operation2]; [queue addOperation:operation3]; [queue addOperation:operation4]; &#125; NSLockNSLock 是对 PTHREAD_MUTEX_ERRORCHECK 类型的 pthread_mutex_t 的封装。 1234567891011121314151617181920212223- (void)useNSLock &#123; NSLock *nsLock = [[NSLock alloc] init]; [nsLock lock]; [self doSomeThingForFlag:1 finish:^&#123; [nsLock unlock]; &#125;]; [nsLock lock]; [self doSomeThingForFlag:2 finish:^&#123; [nsLock unlock]; &#125;]; [nsLock lock]; [self doSomeThingForFlag:3 finish:^&#123; [nsLock unlock]; &#125;]; [nsLock lock]; [self doSomeThingForFlag:4 finish:^&#123; [nsLock unlock]; &#125;];&#125; NSRecursiveLock1234567891011121314151617NSRecursiveLock *recursiveLock;- (void)useNSRecursiveLock &#123; recursiveLock = [[NSRecursiveLock alloc] init]; [self thread2];&#125;- (void)thread2 &#123; [recursiveLock lock]; static int count = 0; count ++; if (count &lt; 10) &#123; NSLog(@"do:%d",count); [self thread2]; &#125; [recursiveLock unlock]; NSLog(@"finish:%d",count);&#125; pthread_cond_t &amp; NSCondition条件变量，可以看看上文中关于睡觉与叫醒那部分，意为当满足条件时，唤醒线程，不满足时线程会进行休眠。 以一个 生产-消费者 模式来看看 pthread_cond_t 如何使用： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960pthread_mutex_t pMutex;pthread_cond_t pCond;NSData *data;int count = 1;- (void)usePthreadCond &#123;// // 初始化锁属性 pthread_mutexattr_t mutexAttr; pthread_mutexattr_init(&amp;mutexAttr); pthread_mutexattr_settype(&amp;mutexAttr, PTHREAD_MUTEX_NORMAL); // 初始化条件变量属性 pthread_condattr_t condAttr; pthread_condattr_init(&amp;condAttr); // 初始化条件变量 pthread_cond_init(&amp;pCond, &amp;condAttr); // 初始化锁 pthread_mutex_init(&amp;pMutex, &amp;mutexAttr); // 销毁 attr pthread_mutexattr_destroy(&amp;mutexAttr); pthread_condattr_destroy(&amp;condAttr); data = nil; [self producter]; // 保证模型能走动，先执行一次生产者的操作 for (int i = 0; i &lt; 10; i++) &#123; dispatch_async(dispatch_get_global_queue(0, 0), ^&#123; [self consumer]; &#125;); dispatch_async(dispatch_get_global_queue(0, 0), ^&#123; [self producter]; &#125;); &#125;&#125;- (void)consumer &#123; // 消费者 pthread_mutex_lock(&amp;pMutex); while (data == nil) &#123; pthread_cond_wait(&amp;pCond, &amp;pMutex); // 等待数据 &#125; // 处理数据 NSLog(@"data is finish"); data = nil; pthread_mutex_unlock(&amp;pMutex);&#125;- (void)producter &#123; // 生产者 pthread_mutex_lock(&amp;pMutex); // 生产数据 data = [[NSData alloc] init]; NSLog(@"preparing data"); sleep(1); pthread_cond_signal(&amp;pCond); // 发出信号，数据已完成 pthread_mutex_unlock(&amp;pMutex);&#125; 然后来看看 NSCondition，它是对 pthread_cond_t 和 pthread_mutex_t 的一个封装： 12345678910111213141516171819202122232425262728293031323334353637383940NSCondition *cond;NSData *ns_data;- (void)useNSCondition &#123; cond = [[NSCondition alloc] init]; ns_data = nil; [self ns_producter]; for (int i = 0; i &lt; 10; i++) &#123; dispatch_async(dispatch_get_global_queue(0, 0), ^&#123; [self ns_consumer]; &#125;); dispatch_async(dispatch_get_global_queue(0, 0), ^&#123; [self ns_producter]; &#125;); &#125;&#125;- (void)ns_consumer &#123; [cond lock]; while (ns_data == nil) &#123; [cond wait]; // 等待数据 &#125; // 处理数据 NSLog(@"data is finish"); [cond unlock];&#125;- (void)ns_producter &#123; [cond lock]; // 生产数据 ns_data = [[NSData alloc] init]; NSLog(@"preparing data"); sleep(1); [cond signal]; // 发出信号，数据已完成 [cond unlock];&#125; 使用 NSCondition 不需要另外创建一个锁，直接使用 [cond lock] 即可。 NSConditionLockNSConditionLock 借助 NSCondition 来实现，它的本质就是一个「生产-消费者」模型。“条件被满足” 可以理解为生产者提供了新的内容。NSConditionLock 的内部持有一个 NSCondition 对象，以及 _condition_value 属性，在初始化时就会对这个属性进行赋值。 12345678// 简化版代码- (id)initWithCondition:(NSInteger)value &#123; if (nil != (self = [super inir])) &#123; _condition = [NSCondition new]; _condition_value = value; &#125; return self;&#125; 它的 lockWhenCondition: 其实就是消费者方法： 123456- (void)lockWhenCondition:(NSInteger)value &#123; [_condition lock]; while (value != _condition_value) &#123; [_condition wait]; &#125;&#125; 对应的 unlockWhenCondition: 方法则是生产者，使用了 boardcast 方法通知所有的消费者： 12345- (void)unlockWithCondition:(NSInteger)value &#123; _condition_value = value; [_condition broadcast]; [_condition unlock];&#125; 下面是一个完整的例子： 123456789101112131415161718192021222324- (void)useNSConditionLock &#123; NSConditionLock *condLock = [[NSConditionLock alloc] initWithCondition:1]; [condLock lockWhenCondition:1]; [self doSomeThingForFlag:1 finish:^&#123; [condLock unlockWithCondition:2]; &#125;]; [condLock lockWhenCondition:2]; [self doSomeThingForFlag:2 finish:^&#123; [condLock unlockWithCondition:3]; &#125;]; [condLock lockWhenCondition:3]; [self doSomeThingForFlag:3 finish:^&#123; [condLock unlockWithCondition:4]; &#125;]; [condLock lockWhenCondition:4]; [self doSomeThingForFlag:4 finish:^&#123; [condLock unlock]; &#125;]; &#125; NSConditionLock 是对 NSCondition 的进一步封装，可以对条件变量赋值，这样我们就可以用它来实现顺序执行线程。 @synchronized是对 pthread_mutex_t 中递归锁的一个封装，苹果不推荐使用，因为性能差。 123456789101112131415- (void)useSynchronized &#123; [self thread5];&#125;- (void)thread5 &#123; static int count = 0; @synchronized (self) &#123; count ++; if (count &lt; 10) &#123; NSLog(@"%d",count); [self thread5]; &#125; &#125; NSLog(@"finish:%d",count);&#125; @synchronized 后面要跟一个 OC 对象，底层会以这个对象对大括号中的代码进行加锁，它实际上是把这个对象当做锁来使用，通过一个哈希表来实现，在 OC 的底层使用了一个互斥锁的数组（可以理解为锁池），通过对象的哈希值来获取对应的互斥锁。所以这其实是一个 OC 层面的锁，主要是通过牺牲性能换来语法上的简洁和可读性。 小结以上的这些 Demo 我放到了 github 中。 同步方案的性能由高到低排序（不绝对，情况不一样性能也有有区别）： OSSpinLock os_unfair_lock dispatch_semaphore pthread_mutex dispatch_queue(DISPATCH_QUEUE_SERIAL) NSLock NSCondition pthread_mutex(recursive) NSRecursiveLock NSConditionLock @synchronized OC 对 pthread 的同种类型的锁、信号量的封装出来的对象，性能都不如直接使用 pthread，主要是因为 OC 多了一个消息传递的过程。 最后贴一下 YYKit 作者的一个性能比较图： 参考文章《计算机的心智操作系统之哲学原理（第2版）》 Linux线程-互斥锁pthread_mutex_t 深入理解 GCD iOS GCD之dispatch_semaphore（信号量） iOS简单优雅的实现复杂情况下的串行需求(各种锁、GCD 、NSOperationQueue…) 不再安全的 OSSpinLock]]></content>
      <categories>
        <category>iOS概念攻坚之路</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>Objective-c</tag>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS概念攻坚之路（四）：多线程]]></title>
    <url>%2F2019%2F06%2F03%2FiOS%E6%A6%82%E5%BF%B5%E6%94%BB%E5%9D%9A%E4%B9%8B%E8%B7%AF%2F%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9A%E5%A4%9A%E7%BA%BF%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[前言我们现在所使用的操作系统模式是 多任务（Multi-tasking）系统，操作系统接管所有的硬件资源，而且本身运行在一个受硬件保护的级别。所有的应用程序都是以 进程（Progress） 的方式运行在比操作系统权限更低的级别。每个进程都有自己独立的地址空间，使得进程之间的地址空间相互隔离。CPU 由操作系统统一进行分配，每个进程根据进程优先级的高低都有机会得到 CPU，但是，如果运行时间超过了一定的事件，操作系统会暂停该进程，将 CPU 资源分配给其他等待运行的进程。这种 CPU 的分配方式即所谓的 抢占式（Preemptive），操作系统可以强制剥夺 CPU 资源并且分配给它认为目前最需要的进程，如果操作系统分配给每个进程的时间都很短，即 CPU 在多个进程间快速的切换，从而造成了很多进程在同时运行的假象。目前几乎所有现代的操作系统都是采用这种方式。 计算机发展早期，一个 CPU 只能运行一个程序，当执行 I/O 操作，比如读取磁盘数据时，CPU 就会处于空闲状态，这显然是一种浪费。后来人们迅速发明了 多道程序（Multiprogramming），当某个程序无需使用 CPU 时，监控程序就把另外的正在等待 CPU 资源的程序启动，不过它没有一个优先级的概念，就算某些任务急需 CPU，也很可能需要等待很长的时间。经过改进后，人们又发明了 分时系统（Time-Share System），每个程序运行一段时间后都主动让出 CPU 给其他程序，使得一段时间内每个程序都有机会运行一小段时间。不过这种系统的问题在于，如果一个程序在进行一个很耗时的操作，一直霸占 CPU，那么操作系统也是没有办法的，比如一个程序进入了一个 while(1) 的死循环，那么整个系统都会停止。再进一步的发展，就是我们上面提到的多任务系统了。 如此发展的目的是，尽可能最大限度的利用 CPU，到这里，出现了一个进程的概念，而线程与进程，有着脱不开的关系。 什么是进程维基百科： 进程（Process），是计算机中 已运行程序 的实体。进程曾经是分时系统的基本运作单位。在面向进程设计的系统（如早期的 UNIX，Linux2.4 及更早的版本）中，进程是程序的基本执行实体；在面向线程设计的系统（如当代多数操作系统，Linux 2.6 及更新版本）中，进程本身不是基本运行单位，而是 线程的容器。程序本身只是 指令，数据及其组织形式的描述，进程才是程序（那些指令和数据）的真正运行实现。 用户下达运行程序的命令后，就会产生进程。同一程序可产生多个进程（一对多关系），以允许同时有多位用户运行同一程序，却不会相互冲突。 进程需要一些资源才能完成工作，如 CPU 使用时间、存储器、文件及 I/O 设备，且为依序逐一进行，也就是每个 CPU 核心任何时间内仅能运行一项进程。 百度百科： 进程（Process） 是计算机中的 程序关于某数据集合上的一次运行活动，是系统进行 资源分配 和调度的基本单位，是操作系统结构的基础。在早期面向进程设计的计算机结构中，进程是程序的基本执行实体；在当代面向线程设计的计算机结构中，进程是线程的容器。程序是指令、数据及其组织形式的描述，进程是程序的实体。 进程是一个具有独立功能的程序关于某数据集合的一次运行活动。它可以申请和拥有系统资源，是一个 动态 的概念，是一个活动的实体。它不只是程序的代码，还包括当前的活动，通过程序计数器的值和处理寄存器的内容来表示。 进程的概念主要有两点：第一，进程是一个实体。每一个进程都有它自己的地址空间，一般情况下，包括文本区域（text region）、数据区域（data region）和堆栈（stack region）。文本区域存储处理器执行的代码；数据区域存储变量和进程执行期间使用的动态分配的内存；堆栈区域存储着活动进程调用的指令和本地变量。第二，进程是一个「执行中的程序」。程序是一个没有生命的实体，只有处理器赋予程序生命时（操作系统执行之），它才能成为一个活动的实体，我们称其为进程。 所以，进程是程序的一个实体，是执行中的程序，而程序是指令、数据及其组织形式的描述。程序不能单独执行，只有将程序加载到内存中，系统为它分配资源后才能够执行，这种 执行的程序 称之为进程。所以进程是一个动态的概念，与程序的区别在于，程序是指令的集合，是进程运行的静态描述文本，而进程则是程序在系统上执行的动态活动。 可以这么理解，我们写的 APP，是一个程序，我们装到手机上，此时它还不是进程，当我们点击它，系统为它分配资源，运行，此时它可以被称为进程。 另外两者都提到，在现代的面向程序设计的计算机结构中，进程是线程的容器。在如今的操作系统中，线程才是最小的调度单位，而进程，是资源分配的最小单位，一个进程包含一个或多个线程。 来看看进程的内容： 那个程序的可执行机器代码的一个在存储器的映象。 分配到别的存储器（通常是一个虚拟的一个存储器区域）。存储器的内容包括可执行代码、特定于进程的数据（输入、输出）、调用堆栈、堆栈（用于保存运行时运输中途产生的数据）。 分配给该进程的资源和操作系统描述符，诸如文件描述符（UNIX术语）或文件句柄（Windows）、数据源和数据终端。 安全特性，诸如进程拥有者和进程的权限集（可以容许的操作）。 处理器状态（中文），诸如寄存器内容、物理存储器定址等。当进程正在运行时，状态通常存储在寄存器，其他情况在存储器。 什么是线程内核线程、轻量级进程、用户线程前面提到，进程是线程的容器，而在现代的多数操作系统中，线程是调度的最小单位。我们来看看线程的定义： 维基百科： 线程（Thread） 是操作系统能够进行运算调度的最小单位。它被包含在进程之中，是进程中的 实际运作单位。一条线程指的是 进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。在 Unix System V 及 SunOS 中也被称为轻量级进程（lightweight processes），但轻量进程更多指内核线程（kernel thread），而把用户线程（user thread）称为线程。 这边提到了几个概念：内核线程，轻量级进程，用户线程，我们分别来看看它们的具体概念： 内核线程 内核线程就是内核的分身，一个分身可以处理一件特定事情。这在处理异步事件如异步 IO 时特别有用。内核线程的使用是廉价的，唯一使用的资源就是内核栈和上下文切换时保存寄存器的空间。支持多线程的内核叫做多线程内核（Multi-Threads kernel）。 内核线程只运行在内核态，不受用户态上下文的拖累。 轻量级进程 轻量级进程（LWP）是一种由 内核支持的用户线程。它是基于内核线程的高度抽象，因此只有先支持内核线程，才能有 LWP。每一个进程有一个或多个 LWP，每个 LWP 由一个内核线程支持。这种模型被称为一对一模型。在这种实现的操作系统中，LWP 就是用户线程。 由于每个 LWP 都与一个特定的内核线程相关联，因此每个 LWP 都是一个独立的线程调度单元。即使有一个 LWP 在系统调用中阻塞，也不会影响整个进程的执行。 轻量级进程的局限性： 大多数 LWP 的操作，如建立、析构以及同步，都需要进行系统调用，系统调用的代价相对较高（需要在用户态和内核态中切换） 每个 LWP 都需要有一个内核线程支持，因此 LWP 要消耗内核资源（内核线程的栈空间）。因此一个系统不能支持大量的 LWP。（图片的 P 指进程） 将之称之为轻量级进程的原因可能是：在内核线程的支持下，LWP 是独立的调度单元，就像普通的进程一样。所以 LWP 的最大特点还是每个 LWP 都有一个内核线程支持。 用户线程 LWP 虽然本质上属于用户线程，但 LWP 线程库是建立在内核之上的，LWP 的许多操作都要进行系统调用，因此效率不高。而这里的用户线程指的是 完全建立在用户空间的线程库，用户线程的建立、同步、销毁、调度完全在用户空间完成，不需要内核的帮助，因此这种线程的操作是及其快速且低消耗的。 上图是最初的一个用户线程模型，从中可以看出，进程中包含线程，用户线程在用户空间中实现，内核并没有直接对用户线程进行调度，内核的调度对象和传统进程一样，还是进程本身，内核并不知道用户线程的存在。用户线程之间的调度由在用户控件的线程库实现。 这是多对一模型，其缺点在于一个用户线程如果阻塞在系统调用中，则整个进程都将会阻塞。 加强版的用户线程 —— 用户线程+LWP 这种模型是所谓的多对多模型。用户线程库还是完全建立在用户空间中，因此用户线程的操作还是很廉价，因此可以建立任意多需要的用户线程。操作系统提供了 LWP 作为用户线程和内核线程之间的桥梁。LWP 还是和前面提到的一样，具有内核线程支持，是内核的调度单元，并且用户线程的系统调用要通过 LWP，因此进程中某个用户线程的阻塞不会影响整个进程的执行。用户线程库将建立的用户线程关联到 LWP 上，LWP 与用户线程的数量不一定一致。当内核调度到某个 LWP 上时，此时与该 LWP 关联的用户线程就被执行。 很多文献中认为轻量级进程就是线程，实际上这种说法并不完全正确，只有在用户线程完全由轻量级进程构成时，才可以说轻量级进程就是线程。 更多有关内核线程、轻量级进程、用户线程三种线程的概念，可以看看 这篇文章。 在现代操作系统中，不再将进程当做操作的基本单元了，而是把线程当做基本单元，一个进程中可以存在多个线程。一个进程内的所有线程都共享虚拟内存空间。进程这个概念依然以一个或多个线程的 容器 的形式保存下来。进程往往都是多线程的，当一个进程只是单线程时，进程和线程两个属于可以互换使用。 线程的结构、访问权限一个标准的线程由线程 ID、当前指令指针（PC）、寄存器集合和堆栈组成。通常意义上，一个进程由一个到多个线程组成，各个线程之间共享程序的内存空间（包括代码段、数据段、堆等）及一些进程级的资源（如打开文件和信号），下面是线程和进程的一个关系结构图： 线程可以访问进程内存里的所有数据，甚至包括其他线程的堆栈（如果它知道其他线程的堆栈地址，不过这种情况很少见），在实际运用中，线程也拥有自己的私有存储空间，包括以下方面： 栈（尽管并非完全无法被其他线程访问，但一般情况下仍然可以认为是私有的资源） TLS（Thread Local Storage，线程局部存储）。TLS 是某些操作系统为线程单独提供的私有空间，通常只具有很有限的容量 寄存器（包括 PC 寄存器），寄存器是执行流的基本数据，因此为线程私有 线程与进程的数据是否私有如下表： 线程私有 进程之间共享（进程所有） 局部变量 全局变量 函数的参数 堆上的数据 TLS 函数的静态变量 程序代码，任何线程都有权利读取并执行任何代码 打开的文件，A 线程打开的文件可以由 B 线程读写 线程调度与优先级不管是多处理器还是单处理器，我们看到的线程似乎总是 “并发” 执行的，实际情况是，只有当线程数量小于或等于处理器的数量时（并且操作系统支持多处理器），线程的并发才是真正的并发（也就是并行），不同的线程运行在不同的处理器上，彼此之间互不相干。对于线程数量大于处理器数量的情况，至少有一个处理器会运行多个线程，此时的并发只是一种模拟出来的状态：操作系统会让这些多线程程序轮流执行，每次仅执行以小段时间（通常是几十到几百毫秒），这样每个线程 “看起来” 在同时执行。 这样的一个不断在处理器上切换不同线程的行为称之为 线程调度（Thread Schedule），在线程调度中，线程通常拥有至少三种状态，分别是： 运行（Running）：此时线程正在执行 就绪（Ready）：此时线程可以立刻执行，但 CPU 已经被占用 等待（Waiting）：此时线程正在等待某一事件（通常是 I/O 或同步）发生，无法执行 来看一下线程的生命周期： 处于运行中线程拥有一段可以执行的时间，这段时间称为时间片（Time Slice），当时间片用尽的时候，该线程进入就绪状态。如果在时间片用尽之前线程就开始等待某事件，那么它将进入等待状态。每当一个线程离开运行状态时，调度系统就会选择一个其他的就绪线程继续执行。在一个处于等待状态的线程所等待的事件发生之后，该线程将进入就绪状态。 线程调度自多任务操作系统问世以来就不断被提出不同的方案和算法。现在主流的调度方式尽管各不相同，但都带有 优先级调度（Priority Schedule） 和 轮转法（Round Robin） 的痕迹。所谓轮转法，即是之前提到的让各个线程轮流执行一小段时间的方法，这决定了线程之间是交错运行的。而优先级调度则决定了线程按照什么顺序轮流执行。在具有优先级调度的系统中，线程都拥有各自的 线程优先级（Thread Priority）。具有高优先级的线程会更早的执行，而低优先级的线程常常要等到系统中已经没有高优先级的可执行的线程存在时才能够执行。 系统会根据不同线程的表现自动调整优先级，以使得调度更有效率。例如通常情况下，频繁的进入等待状态（进入等待状态，会放弃之后仍然课占用的时间份额，也就是我们说的线程休眠，不会占用 CPU 资源）的线程（例如处理 I/O 的线程）比频繁进行大量计算，以至于每次都要把时间片全部用尽的线程要受欢迎的多。一般把频繁等待的线程称之为 IO 密集型线程（IO Bound Thread），而把很少等待的线程称为 CPU 密集型线程（CPU Bound Thread）。IO 密集型线程总是比 CPU 密集型线程容易得到优先级的提升。 在优先级调度下，存在一种 饿死（Starvation） 的现象，一个线程被饿死，是说它的优先级较低，在它执行之前，总是有高优先级的线程要执行，因此这个低优先级线程始终无法执行。当一个 CPU 密集型线程获得较高的优先级时，许多低优先级的线程就很可能饿死。而一个高优先级的 IO 密集型线程由于大部分时间都处于等待状态，因此相对不容易造成其他线程饿死。为了避免饿死现象，调度系统常常会逐步提升那些等待了过长时间的得不到执行的线程的优先级。在这样的手段下，一个线程只要等待足够多的事件，其优先级一定会提高到足够让它执行的程度。 总结一下，在优先级调度的环境下，线程的优先级改变一般有三种方式： 用户指定优先级 根据进入等待状态的频繁程度提升或降低优先级 长时间得不到执行而被提升优先级 线程安全多线程程序处于一个多变的环境当中，可访问的全局变量和堆数据随时都可能被其他的线程改变，因此多线程程序在并发时数据的一致性变得非常重要。 为了避免多个线程同时读写同一个数据而产生不可预料的后果，我们要将各个线程对同一个数据访问 同步（Synchronization）。所谓同步，即指在一个线程访问数据未结束的时候，其他线程不得对同一个数据进行访问。如此，对数据的访问被原子化了。 原子操作：单指令的操作，无论如何，单条指令的执行都不会被打断。 同步的最常见方法是使用 锁（Lock）。锁是一种非强制机制，每一个线程在访问数据或资源之前首先试图 获取（Acquire） 锁，并在访问结束之后 释放（Release） 锁。在锁已经被占用的时候试图获取锁时，线程会等待，直到锁重新可用。 二元信号量（Binary Semaphore） 是最简单的锁，它只有两种状态：占用与非占用。它适合只能被唯一一个线程独占访问的资源。当二元信号量处于非占用状态时，第一个试图获取该二元信号量的线程会获得该锁，并将二元信号量置为占用状态，此后其他的所有试图获取该二元信号量的线程将会等待，直到该锁被释放。 对于允许多个线程并发访问的资源，多元信号量简称 信号量（Semaphore），它是一个很好的选择。一个初始值为 N 的信号量允许 N 个线程并发访问。线程访问资源的时候首先获取信号量，进行如下操作： 将信号量的值减 1 如果信号量的值小于 0，则进入等待状态，否则继续执行 访问完资源之后，线程释放信号量，进行如下操作： 将信号量的值加 1 如果信号量的值小于 1，唤醒一个等待中的线程 互斥量（Mutex） 和二元信号量很类似，资源仅同时允许一个线程访问，但和信号量不同的是，信号量在整个系统可以被任意线程获取并释放，也就是说，同一个信号量可以被系统中的一个线程获取之后由另一个线程释放。而互斥量则要求哪个线程获取了互斥量，哪个线程就要负责释放这个锁，其他线程去释放互斥量是无效的。 临界区（Cirtical Section） 是比互斥量更加严格的同步手段。在术语中，把临界区的锁的获取称为进入临界区，而把锁的释放称为离开临界区。临界区和互斥量与信号量的区别在于，互斥量和信号量在系统的任何进程里都是可见的，也就是说，一个进程创建了一个互斥量或信号量，另一个进程试图去获取该锁是合法的。然而，临界区的作用范围仅限于本进程，其他的进程无法获取该锁。除此之外。临界区具有和互斥量相同的性质。 读写锁（Read-Write Lock） 致力于一种更加特定的场合的同步。对于一段数据，多个线程同时读取总是没有问题的，但假设操作都不是原子型，只要有任何一个线程试图对这个数据进行修改，就必须使用同步的手段来避免出错。如果我们使用上述信号量、互斥量或临界区中的任何一种来进行同步，尽管可以保证程序正确，但对于读取频繁，而仅仅偶尔写入的情况，会显得非常低效。读写锁可以避免这个问题。对于同一个锁，读写锁有两种获取方式，共享的（Shared） 和 独占的（Exclusive）。当锁处于自由的状态时，试图以任何一种方式获取锁都能成功，并将锁置于对应的状态。如果锁处于共享状态，其他线程以共享的方式获取锁仍然会成功，此时这个锁被分配给了多个线程。然而，如果其他线程试图以独占的方式获取已经处于共享状态的锁，那么它将必须等待锁被所有的线程释放。相应的，处于独占状态的锁将阻止任何其他线程获取该锁，不论它们试图以哪种方式获取。读写锁的行为可以总结为下表： 读写锁状态 以共享方式获取 以独占方式获取 自由 成功 成功 共享 成功 等待 独占 等待 等待 条件变量（Condition Variable） 作为一种同步手段，作用类似于一个栅栏。对于条件变量，线程可以有两种操作，首先线程可以等待条件变量，一个条件变量可以被多个线程等待。其次，线程可以唤醒条件变量，此时某个或所有等待此条件变量的线程都会被唤醒并继续支持。也就是说，使用条件变量可以让许多线程一起等待某个事件的发生，当事件发生时（条件变量被唤醒），所有的线程可以一起恢复执行。 锁与线程同步，会单独再开一篇文章来说，锁的概念都是一样的，只是实现的手段不一样。 线程和进程的由来我在看 进程和线程的一个简单解释 这篇文章的时候，看到一个回答，用来说明进程和线程的由来比较合适： 在单核计算机里，有一个资源是无法被多个应用程序并行使用的：CPU。 没有操作系统的情况下，一个程序一直独占着全部 CPU。 如果要有两个任务来共享一个 CPU，程序员就需要仔细地为程序安排好运行计划 —— 某时刻 CPU 由程序 A 来独享，下一时刻 CPU 由程序 B 来独享。 而这种安排计划后来成为 OS 的核心组件，被单独命名为 Scheduler（调度器）。它关心的只是怎样把单个 CPU 的运行拆分成一段一段的 “运行片”，轮流分给不同的程序去使用，而在宏观上，因为分配切换的速度极快，就制造出多线程并行在一个 CPU 上的假象。 在单核计算机里，有一个资源可以被多个程序共用，然而会引出麻烦：内存。 在一个只有调度器，没有内存管理组件的操作系统上，程序员需要手工为每个程序安排运行的空间 —— 程序 A 使用武力地址 0x00-0xff，程序 B 使用物理地址 0x100-0x1ff，等等。 然而这样做有个很大的问题：每个程序都要协调商量好怎样使用同一个内存上的不同空间，软件系统和硬件系统千差万别，使这种定制方案没有可行性。 为了解决这个麻烦，计算机引入了「虚拟内存」的概念，从三方面入手来做： 硬件上，CPU 增加了一个专门的模块叫 MMU，负责转换虚拟地址和物理地址 操作系统上，操作系统增加了另一个核心组件：「Memory Management」，即内存管理模块，它管理物理内存、虚拟内存相关的一系列事务。 应用程序上，发明了一个叫做「进程」的模型，每个进程都用 完全一样 的虚拟地址空间，然后经由操作系统和硬件 MMU 协作，映射到不同的物理地址空间上。不同的「进程」都有各自独立的物理内存空间，不用一些特殊手段，是无法访问别的进程的物理内存的。 现在，不同的应用程序，可以不关心底层的物理内存分配，也不关心 CPU 的协调共享了。然而还有一个问题存在：有一些程序，想要共享 CPU，并且还要共享同样的物理内存，这时候，一个叫「线程」的模型就出现了，它们被包裹在进程里面，在调度器的管理下共享 CPU，拥有同样的虚拟空间地址，同时也共享同一个物理地址空间，然而，它们无法越过包裹自己的进程，去访问另外一个进程的物理地址空间。 为什么要使用多线程 某个操作可能会陷入长时间等待，等待的线程会进入睡眠状态，无法继续执行。多线程执行可以有效利用等待的时间，典型的例子就是等待网络响应。 某个操作（常常是计算）会消耗大量的时间，如果只有一个线程，程序和用户之间的交互会中断。多线程可以让一个线程负责交互，另一个线程负责计算。 程序逻辑本身就要求并发操作，例如一个多端下载软件。 多 CPU 或多核计算机，本身就具有同时执行多个线程的能力，因此单线程程序无法全面的发挥计算机的全部计算能力。 相对于多进程引用，多线程在数据共享方面效率要高很多。 总结其实我们最主要是两个问题：什么是进程和什么是线程。 什么是进程？ 进程是计算机中已运行程序的主体，在之前的分时系统中，是系统的基本运作单位。不过在如今的面向线程设计的系统中，进程是线程的容器。它的概念主要有两点：第一，进程是一个实体，每一个进程都有它自己的地址空间。第二，进程是一个执行中的程序，程序是一个没有生命的实体，只有处理器赋予程序生命（如点击运行），它才能成为一个活动的实体，也就是进程。 进程是系统进行资源分配的最小单位。 什么是线程？ 线程，有时候被称为轻量级进程，它包含在进程之中，是进程中的实际运作单位，一条线程指的是进程中一个单一顺序的执行流。线程共享进程的所有数据并且拥有自己私有的存储空间。线程又分内核线程和用户线程。 线程是系统进行调度的最小单位。 当我们要运行一个程序，系统为我们分配资源，然后运行，此时称为进程，然而真正运行的不是进程，而是进程内的某个执行流，也就是线程，一个进程至少有一条线程。 另外还有线程相关的一些知识点，比如线程的访问权限、结构、生命周期、安全等。 关于线程和进程的话题经久不息，如果文中有理解错误的地方，欢迎大家指出。 参考文章iOS 多线程全套 内核线程、轻量级进程、用户线程三种线程概念解惑（线程≠轻量级进程） 进程和线程的一个简单解释]]></content>
      <categories>
        <category>iOS概念攻坚之路</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>Objective-c</tag>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS概念攻坚之路（三）：内存管理]]></title>
    <url>%2F2019%2F05%2F29%2FiOS%E6%A6%82%E5%BF%B5%E6%94%BB%E5%9D%9A%E4%B9%8B%E8%B7%AF%2F%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[前言iOS 的内存管理不止是 「引用计数表」。 iOS 开发者基本都知道 iOS 是通过「引用计数」来管理内存的，但是也许并不知道 iOS 其他的内存管理方式，比如 「Tagged Pointer」（带标记的指针），比如 「NONPOINTER_ISA」（非指针型 isa），这个要根据不同的场景进行区分。 我们就这篇文章主要来谈一谈这三种内存管理方式。 关于内存在说内存管理之前，我们先来说一下关于内存的概念。 内存是计算机中重要的部件之一，它是与 CPU 进行沟通的桥梁。计算机中所有的程序都是在内存中进行的。内存（Menory）也被成为「内存储器」和「主存储器」，其作用是用于暂时存放 CPU 中的运算数据，以及与硬盘等外部存储器交换的数据。只要计算机在运行中，CPU 就会把需要运算的数据调到内存中进行运算，当运算完成后 CPU 再将结果传送出来，内存的运行也决定了计算机的稳定运行。（来自 度娘） 在 App 启动后，系统会把 App 程序拷贝到内存中，然后在内存中执行代码。 内存的概念大家多多少少都有点了解，我们也不说那么多。一块内存条，是一个从下至上、地址依次递增结构。来看一下内存的分区： 上面这张图来自 这里。 大致说一下 iOS 内存分区的情况，五大区域： 栈区（Stack） 由编译器自动分配释放，存放函数的参数，局部变量的值等 栈是向低地址扩展的数据结构，是一块连续的内存区域 堆区（Heap） 由程序员分配释放 是向高地址扩展的数据结构，是不连续的内存区域 全局区 全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域，未初始化的全局变量和未初始化的静态变量在相邻的另一块区域 程序结束后由系统释放 常量区 常量字符串就是放在这里的 程序结束后由系统释放 代码区 存放函数体的二进制代码 另外说一下一些值得注意的地方： 在 iOS 中，堆区的内存是应用程序内共享的，一个应用程序其实就是一个进程，也就是进程内的内存是共享的。堆中的内存分配是需要程序员负责的 系统使用一个链表来维护所有已经分配的内存空间（系统仅仅记录，并不管理具体的内容） 变量使用结束后，需要释放内存，OC 中是判断引用计数是否为 0，如果是就说明没有任何变量使用该空间，那么系统将其回收 当一个 app 启动后，代码区、常量区、全局区大小就已经固定，因此指向这些区的指针不会产生崩溃性的错误。而堆区和栈区是时时刻刻变化的（堆的创建销毁，栈的弹入弹出），所以当使用一个指针指向这个区里面的内存时，一定要注意内存是否已经被释放，否则会产生程序崩溃（也即是野指针报错） Tagged Pointer 为了节省内存和提高执行效率，苹果提出了 Tagged Pointer 的概念。对于 64 位程序，引入 Tagged Pointer 后，相关逻辑能减少一半的内存占用，以及 3 倍的访问速度提升，100 倍的创建、销毁速度提升。 （有没有那么牛逼咱也不知道，咱也不敢问） 我们先看看原有的对象为什么会浪费内存，假设我们要存储一个 NSNumber 对象，其值是一个整数。正常情况下，如果这个整数只是一个 NSInteger 的普通变量，那么它所占用的内存是与 CPU 的位数有关，在 32 位 CPU 下占 4 个字节，在 64 位 CPU 下是占 8 个字节的。而指针类型的大小通常也是与 CPU 位数相关的，一个指针所占用的内存在 32 位 CPU 下为 4 个字节，在 64 位 CPU 下也是 8 个字节。 所以一个普通的 iOS 程序，如果没有 Tagged Pointer 对象，从 32 位机器迁移到 64 位机器中后，虽然逻辑没有任何变化，但这种 NSNumber、NSDate 一类的对象所占用的内存会翻倍。 我们再来看看效率上的问题，为了存储和访问一个 NSNumber 对象，我们需要在堆上为其分配内存，另外还要维护它的引用计数，管理它的生命周期。这些都给程序增加了额外的逻辑，造成了运行效率上的损失。 所以为了改进上面提到的内存占用和效率问题，苹果提出了 Tagged Pointer 对象，由于 NSNumber、NSDate 一类的变量本身的值需要占用的内存大小常常不需要 8 个字节，拿整数来说，4 个字节所能表示的有符号整数就可以达到 20 多亿（2 ^ 31 = 2147483648，另外 1 位作为符号位），对于绝大多数情况都是可以处理的。 所以我们可以将一个对象的指针拆分成两部分，一部分直接保存数据，另一部分作为特殊标记，表示这是一个特别的指针，不指向任何一个地址。 Tagged Pointer 特点： Tagged Pointer 专门用来存储小的对象，例如 NSNumber 和 NSDate Tagged Pointer 指针的值不再是地址了，而是真正的值。所以，实际上它不再是一个对象了，它只是一个披着对象皮的普通变量而已。所以，它的内存并不存储在堆中，也不需要 malloc 和 free 在内存读取上有着 3 倍的效率，创建时比以前快 106 倍 objc_msgSend 能识别 Tagged Pointer，比如 NSNumber 的 intValue 方法，直接从指针提取数据 使用 Tagged Pointer 后，指针内存储的数据变成了 Tag + Data，也就是将数据直接存储在了指针中 NONPOINTER_ISA苹果将 isa 设计成了联合体，在 isa 中存储了与该对象相关的一些内存的信息，原因也如上面所说，并不需要 64 个二进制位全部都用来存储指针。 来看一下 isa 的结构： 12345678910111213141516171819202122232425// x86_64 架构struct &#123; uintptr_t nonpointer : 1; // 0:普通指针，1:优化过，使用位域存储更多信息 uintptr_t has_assoc : 1; // 对象是否含有或曾经含有关联引用 uintptr_t has_cxx_dtor : 1; // 表示是否有C++析构函数或OC的dealloc uintptr_t shiftcls : 44; // 存放着 Class、Meta-Class 对象的内存地址信息 uintptr_t magic : 6; // 用于在调试时分辨对象是否未完成初始化 uintptr_t weakly_referenced : 1; // 是否被弱引用指向 uintptr_t deallocating : 1; // 对象是否正在释放 uintptr_t has_sidetable_rc : 1; // 是否需要使用 sidetable 来存储引用计数 uintptr_t extra_rc : 8; // 引用计数能够用 8 个二进制位存储时，直接存储在这里&#125;;// arm64 架构struct &#123; uintptr_t nonpointer : 1; // 0:普通指针，1:优化过，使用位域存储更多信息 uintptr_t has_assoc : 1; // 对象是否含有或曾经含有关联引用 uintptr_t has_cxx_dtor : 1; // 表示是否有C++析构函数或OC的dealloc uintptr_t shiftcls : 33; // 存放着 Class、Meta-Class 对象的内存地址信息 uintptr_t magic : 6; // 用于在调试时分辨对象是否未完成初始化 uintptr_t weakly_referenced : 1; // 是否被弱引用指向 uintptr_t deallocating : 1; // 对象是否正在释放 uintptr_t has_sidetable_rc : 1; // 是否需要使用 sidetable 来存储引用计数 uintptr_t extra_rc : 19; // 引用计数能够用 19 个二进制位存储时，直接存储在这里&#125;; 注意这里的 has_sidetable_rc 和 extra_rc，has_sidetable_rc 表明该指针是否引用了 sidetable 散列表，之所以有这个选项，是因为少量的引用计数是不会直接存放在 SideTables 表中的，对象的引用计数会先存放在 extra_rc 中，当其被存满时，才会存入相应的 SideTables 散列表中，SideTables 中有很多张 SideTable，每个 SideTable 也都是一个散列表，而引用计数表就包含在 SideTable 之中。 SideTables原理引用计数要么存放在 isa 的 extra_rc 中，要么存放在引用计数表中，而引用计数表包含在一个叫 SideTable 的结构中，它是一个散列表，也就是哈希表。而 SideTable 又包含在一个全局的 StripeMap 的哈希映射表中，这个表的名字叫 SideTables。 散列表（Hash table，也叫哈希表），是根据建（Key）而直接访问在内存存储位置的数据结构。也就是说，它通过一个关于键值得函数，将所需查询的数据映射到表中一个位置来访问记录，这加快了查找速度。这个映射函数称作散列函数，存放记录的数组称作散列表。 来看一下 NSObject.mm 中它们对应的源码： 12345678910111213// SideTablesstatic StripedMap&lt;SideTable&gt;&amp; SideTables() &#123; return *reinterpret_cast&lt;StripedMap&lt;SideTable&gt;*&gt;(SideTableBuf);&#125;// SideTablestruct SideTable &#123; spinlock_t slock; // 自旋锁 RefcountMap refcnts; // 引用计数表 weak_table_t weak_table; // 弱引用表 // other code ...&#125;; 它们的关系如下图： 一个 SideTables 包含众多 SideTable，每个 SideTable 中又包含了三个元素，spinlock_t 自旋锁、RefcountMap 引用计数表、weak_table_t 弱引用表。所以既然 SideTables 是一个哈希映射的表，为什么不用 SideTables 直接包含自旋锁，引用计数表和弱引用表呢？这是因为在众多线程同时访问这个 SideTable 表的时候，为了保证数据安全，需要给其加上自旋锁，如果只有一张 SideTable 的表，那么所有数据访问都会出一个进一个，单线程进行，非常影响效率，虽然自旋锁已经是效率非常高的锁，这会带来非常不好的用户体验。针对这种情况，将一张 SideTable 分为多张表的 SideTables，再各自加锁保证数据的安全，这样就增加了并发量，提高了数据访问的效率，这就是为什么一个 SideTables 下涵盖众多 SideTable 表的原因。 自旋锁：计算机科学用于多线程同步的一种锁，线程会反复检查锁变量是否可用。由于线程在这一过程中保持执行（没有进入休眠），因此是一种忙等。一旦获取了自旋锁，线程会一直保持该锁，直至显式释放自旋锁。 自旋锁适用于小型数据、耗时很少的操作，速度很快。 弱引用表也是一张哈希表的结构，其内部包含了每个对象对应的弱引用表 weak_entry_t，而 weak_entry_t 是一个结构体数组，其中包含的则是每一个对象弱引用的对象所对应的弱引用指针。 如何进行引用计数操作当需要去查找一个对象对应的 SideTable 并进行引用计数或者弱引用计数的操作时，系统又是怎样实现的呢？ 当一个对象访问 SideTables 时： 首先会取得对象的地址，将地址进行哈希运算，与 SideTables 中 SideTable 的个数取余，最后得到的结果就是该对象所要访问的 SideTable 在取得的 SideTable 中的 RefcountMap 表中再进行一次哈希查找，找到该对象在引用计数表中对应的位置 如果该位置存在对应的引用计数，则对其进行操作，如果没有对应的引用计数，则创建一个对应的 size_t 对象，其实就是一个 uint 类型的无符号整型 引用计数 引用计数（Reference Count）是一个简单而有效的管理对象生命周期的方式。当我们创建一个新对象的时候，它的引用计数为 1，当有一个新的指针指向这个对象时，我们将其引用计数加 1，当某个指针不再指向这个对象时，我们将其引用计数减 1，当对象的引用计数变为 0 时，说明这个对象不再被任何指针指向了，这个时候我们就可以将对象销毁，回收内存。 上面是唐巧的 理解 iOS 的内存管理 中对引用计数的一个定义，简单来说就是采取计数的方式对内存进行管理，内存首先需要被创建出来，然后有人用这块内存，计数 +1，那个人不用了，计数 -1，如果计数为 0，释放它。 当然，创建、使用、释放是有一个规则的，来看一下 iOS 中内存管理的思考方式： 自己生成的对象，自己所持有 非自己生成的对象，自己也能持有 不再需要自己持有的对象时释放 非自己持有的对象无法释放 与之对应的 Objective-C 方法： 对象操作 Objective-C 方法 生成并持有对象 alloc/new/copy/mutableCopy 等方法 持有对象 retain 方法 释放对象 release 方法 废弃对象 dealloc 方法 这些有关 Objective-C 内存管理的方法，实际上不包括在 Objective-C 语言中，而是包含在 Cocoa 框架中用于 OS X，iOS 应用开发，swift 也采用引用计数的方式进行内存管理。Cocoa 框架中 Foundation 框架类库的 NSObject 类担负内存管理的职责。Objective-C 内存管理中的 alloc/retain/release/dealloc 方法分别指代 NSObject 类的 +alloc、-retain、-release、-dealloc 方法。 而引用计数又分为 MRC（Manual Reference Counting，手动引用计数） 和 ARC（Automatic Reference Counting，自动引用计数）。 我们来看一下官方对于自动引用计数的说明： 在 Objective-C 中采用 Automatic Reference Counting（ARC）机制，让编译器来进行内存管理。在新一代 Apple LLVM 编译器(LLVM 3.0 或以上)中设置 ARC 为有效状态，就无需再次键入 retain 或者 release 代码，这在降低程序崩溃、内存泄漏等风险的同时，很大程度上减少了开发程序的工作量。编译器完全清楚目标对象，并能立刻释放那些不再被使用的对象，如此一来，应用程序将具有可预测性，且能流畅运行，速度也将大幅提升。 其实最主要的是一点： 在 LLVM 编译器中设置 ARC 为有效状态，就无需再次键入 retain 或者是 release 代码。 那么我们也就知道了 MRC 是怎么回事了，MRC 就是需要程序员手动插入 retain、release 等管理内存的代码，不过现在 MRC 已经属于远古时代的事情了，这里只是顺便提提，我们主要看 ARC，ARC 其实做的事情不止是自动插入管理内存的方法，还做了一些优化，我们放到后面一点讲。我们先来看看 alloc/retain/release/dealloc 这几个方法的大致实现，这里有一份编译好的 runtime 源码，版本是 objc4-750，或者大家可以到 opensource.apple 去下载。 allocNSObject 中类方法 alloc 做的事情： 首先看看 alloc 方法的实现： 123+ (id)alloc &#123; return _objc_rootAlloc(self);&#125; alloc 中调用 _objc_rootAlloc()。 12345id _objc_rootAlloc(Class cls)&#123; return callAlloc(cls, false/*checkNil*/, true/*allocWithZone*/);&#125; _objc_rootAlloc 中调用 callAlloc()。 123456789static ALWAYS_INLINE idcallAlloc(Class cls, bool checkNil, bool allocWithZone=false)&#123; // some code ... id obj = class_createInstance(cls, 0); return obj; &#125; 省略了一部分代码，callAlloc 中会调用 class_createInstance() 。 12345id class_createInstance(Class cls, size_t extraBytes)&#123; return _class_createInstanceFromZone(cls, extraBytes, nil);&#125; class_createInstance() 中直接调用 _class_createInstanceFromZone，调用 calloc 方法分配内存。 12345678910111213static __attribute__((always_inline)) id_class_createInstanceFromZone(Class cls, size_t extraBytes, void *zone, bool cxxConstruct = true, size_t *outAllocatedSize = nil)&#123; // some code ... id obj; obj = (id)calloc(1, size); // 此时分配内存 obj-&gt;initInstanceIsa(cls, hasCxxDtor); return obj;&#125; _class_createInstanceFromZone 中会调用 obj-&gt;initInstanceIsa()，以下就是初始化的方法了，此时内存已经分配。 12345inline void objc_object::initInstanceIsa(Class cls, bool hasCxxDtor)&#123; initIsa(cls, true, hasCxxDtor);&#125; initInstanceIsa() 中调用 initIsa()。 1234567891011121314151617181920inline void objc_object::initIsa(Class cls, bool nonpointer, bool hasCxxDtor) &#123; if (!nonpointer) &#123; isa.cls = cls; &#125; else &#123; isa_t newisa(0);#if SUPPORT_INDEXED_ISA newisa.bits = ISA_INDEX_MAGIC_VALUE; newisa.has_cxx_dtor = hasCxxDtor; newisa.indexcls = (uintptr_t)cls-&gt;classArrayIndex();#else newisa.bits = ISA_MAGIC_VALUE; newisa.has_cxx_dtor = hasCxxDtor; newisa.shiftcls = (uintptr_t)cls &gt;&gt; 3;#endif isa = newisa; &#125;&#125; 这里就是对 isa 的一个初始化。 所以关于 alloc 方法，其大概步骤如下： alloc/allocWithZone class_createInstance / initInstanceIsa calloc (在这一步开始分配内存) initIsa (初始化 isa 指针里面的内容) 关于 NSObject 的源码解析大家可以看看以下两篇文章： iOS底层探索 - 实例对象的创建 iOS NSObject.mm 源码解析 slowpath 和 fastpath这里我想提一嘴 slowpath 和 fastpath，看一下 callAlloc 的完整实现： 1234567891011121314151617181920212223242526static ALWAYS_INLINE idcallAlloc(Class cls, bool checkNil, bool allocWithZone=false)&#123; if (slowpath(checkNil &amp;&amp; !cls)) return nil;#if __OBJC2__ if (fastpath(!cls-&gt;ISA()-&gt;hasCustomAWZ())) &#123; if (fastpath(cls-&gt;canAllocFast())) &#123; // No ctors, raw isa, etc. Go straight to the metal. bool dtor = cls-&gt;hasCxxDtor(); id obj = (id)calloc(1, cls-&gt;bits.fastInstanceSize()); if (slowpath(!obj)) return callBadAllocHandler(cls); obj-&gt;initInstanceIsa(cls, dtor); return obj; &#125; else &#123; // Has ctor or raw isa or something. Use the slower path. id obj = class_createInstance(cls, 0); if (slowpath(!obj)) return callBadAllocHandler(cls); return obj; &#125; &#125;#endif if (allocWithZone) return [cls allocWithZone:nil]; return [cls alloc];&#125; 注意到方法中使用到的 slowpath 和 fastpath，其实这两个都是宏定义，与代码逻辑本身无关，定义如下： 1234// x 很可能不为 0，希望编译器进行优化#define fastpath(x) (__builtin_expect(bool(x), 1))// x 很可能为 0，希望编译器进行优化#define slowpath(x) (__builtin_expect(bool(x), 0)) 其实它们是所谓的快路径和慢路径，为了解释这个，我们来看一段代码： 1234if (x) return 1;else return 39; 由于计算机并非一次只读取一条指令，而是读取多条指令，所以在读到 if 语句时也会把 return 1 读取进来。如果 x 为 0，那么会重新读取 return 39，重读指令相对来说比较耗时。 如果 x 有非常大的概率是 0，那么 return 1 这条指令每次不可避免的会被读取，并且实际上几乎没有机会执行，造成了不必要的指令重读。 因此，在苹果定义的两个宏中，fastpath(x) 依然返回 x，只是告诉编译器 x 的值一般不为 0，从而编译可以进行优化。同理，slowpath(x) 表示 x 的值很可能为 0，希望编译器进行优化。 这个例子的讲解来自 bestsswifter 的 深入理解GCD，大家感兴趣可以看看。 所以以下代码的解释就出来了： 12// 很可能 cls 是有值的，编译器可以不用每次都读取 return nil 指令 if (slowpath(checkNil &amp;&amp; !cls)) return nil; fastpath 也是同样的机制，但是大家要知道，当 checkNil &amp;&amp; !cls 判断成立的时候，return nil 指令还是会被读取，然后执行的。 还有一个就是 #if __OBJ2__、#endif，如果查看源码的话，还会碰到 #if !__LP64__、#elif 1、#else 这类的宏判断，这是因为苹果针对不同的版本做了不同的实现，比如 32 位架构下和 64 位架构下的实现，有一些代码在不同的情况下是不需要参与编译的，其实也跟我们平时的 if-else 是一样的概念。 retain &amp; releaseretain 方法用于增加引用计数，release 用于减少引用计数。那么引用计数存储在哪里？其实有两个地方，一个是 NONPOINTER_ISA，也就是非指针型 isa 中，isa 有个 extra_rc 属性，就是用于存放引用计数的，在 ARM 64 下，extra_rc 占 19 位。 extra_rc 只会保存额外的自动引用计数，对象的实际的引用计数会在这个基础上 +1。当 isa 的 extra_rc 中存不下的时候，会使用 SideTable 来存储，SideTable 中包含了我们大家都知道的引用计数表。 通过引用计数表管理引用计数的好处在于： 对象用内存块分配无需考虑内存块头部 引用计数表各记录中存有内存块地址，可从各个记录追溯到各对象的内存块 第二点在调试时有着举足轻重的作用，即使出现故障导致对象占用的内存块损坏，但只要引用计数表没有被破坏，就能够确认各内存块的位置。另外，在利用工具检测内存泄漏时，引用计数表的记录也有助于检测各个对象的持有者是否存在。 如果想了解 retain 和 release 的底层实现，可以看一下 黑箱中的 retain 和 release。 autorelease简介顾名思义，autorelease 就是自动释放。这看上去很像 ARC，但实际上它更类似于 C 语言中自动变量（局部变量）的特性。 在计算机编程领域，自动变量（Automatic Variable）指的是局部作用域变量，具体来说即是在控制流进入变量作用域时系统自动为其分配存储空间，并在离开作用域时释放空间的一类变量。 程序执行时，若某自动变量超出其作用域，该自动变量将被自动废弃。 autorelease 会像 C 语言的自动变量那样来对待对象实例，当超出其作用域（相当于变量作用域）时，对象实例的 release 实例方法被调用。另外，同 C 语言的自动变量不同的是，编程人员可以设定变量的作用域。 需要被自动释放的对象会被添加到离它最近的自动释放池中（AutoreleasePool），我们先明确什么对象会自动加入自动释放池： MRC 下需要对象调用 autorelease 才会入池，ARC 下可以通过 __autoreleasing 修饰符，否则的话看方法名，通过 alloc/new/copy/mutablecopy 以外的方法取得的对象，编译器帮我们自动加入 autoreleasepool。（使用 alloc/new/copy/mutablecopy 方法进行初始化时，由系统管理对象，在适当的位置 release，不加入 autoreleasepool） 使用 array 会自动将返回对象注册到 autoreleasepool __weak 修饰的对象，为了保证在引用时不被废弃，会被注册到 autoreleasepool 中 id 的指针或对象的指针，在没有显式指定时会被注册到 autoreleasepool 中 那 Autorelease 的对象什么时候释放？ 在没有手动添加 AutoreleasePool 的情况下，Autorelease 对象是在当前的 runloop 迭代结束时释放的，而它能够释放的原因是系统在每个 runloop 迭代中都加入了自动释放池的 Push 和 Pop。 App 启动后，苹果在主线程 runLoop 里注册了两个 Observer，其回调都是 _wrapRunLoopWithAutoreleasePoolHandler()。 第一个 Observer 监视的事件是 Entry(即将进入 loop)，其回调会调用 _objc_autoreleasePoolPush() 创建自动释放吃。其 order 是 -2147483647，优先级最高，保证创建释放池发生在其他所有回调之前。 第二个 Observer 监视了两个事件：BeforeWaiting(准备进入休眠) 时调用 _objc_autoreleasePoolPop() 和 _objc_autoreleasePoolPush() 释放旧的池并创建新池；Exit(即将退出 Loop) 时调用 _objc_autoreleasePoopPop() 来释放自动释放池，这个 Observer 的 order 是 2147483647，优先级最低，保证释放池释放发生在其他所有回调之后。 在主线程执行的代码，通常是写在诸如事件回调、Timer 回调内的。这些回调会被 RunLoop 创建好的 AutoreleasePool 环绕着，所以不会出现内存泄漏，开发者也不必显式创建 Pool。 使用方法autorelease 的具体使用方法如下： 生成并持有 NSAutoreleasePool 对象 调用已分配对象的 autorelease 实例方法 废弃 NSAutoreleasePool 对象 NSAutoreleasePool 对象的生存周期相当于 C 语言变量的作用域，对于所有调用过 autorelease 实例方法的对象，在废弃 NSAutoreleasePool 对象时，都将调用 release 实例方法。 1234567NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];id obj = [[NSObject alloc] init];[obj autorelease];[pool drain]; // 等同于 [obj release] 在 Cocoa 框架中，相当于程序主循环的 NSRunLoop 或者在其他程序可运行的地方，对 NSAutoreleasePool 对象进行生成、持有和废弃处理。因此，开发者一般不需要使用手动创建释放池。Objective-C 的 main.m 的 UIApplicationMain 方法就是被一个自动释放池环绕着的，也就是说，整个 iOS 应用都是包含在一个自动释放池 block 中： 12345int main(int argc, char * argv[]) &#123; @autoreleasepool &#123; return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class])); &#125;&#125; 不过，在大量产生 autorelease 的对象时，只要不废弃 NSAutoreleasePool 对象，那么生成的对象就不能被释放，因此有时会由于内存不足而到达内存峰值。典型的例子是读入大量图片的同时改变其尺寸，图像文件读入到 NSData 对象，并从中生成 UIImage 对象，改变该对象尺寸后生成新的 UIImage 对象。这种情况下，就会大量产生 autorelease 的对象： 1234567for (int i = 0; i &lt; 图像数 ; ++i) &#123; /* 读入图像 * 大量产生 autorelease 的对象 * 由于没有废弃 NSAutoreleasePool 对象 * 最终导致内存不足! */&#125; 在这种情况下，有必要在适当的地方生成、持有或废弃 NSAutoreleasePool 对象： 123456789101112131415for (int i = 0; i &lt; 图像数; ++i) &#123; NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init]; /* * 读入图像 * 大量产生 autorelease 的对象 */ [pool drain]; /* * 通过 [pool drain], * autorelease 的对象被一起 release。 */&#125; 在 ARC 下我们使用 @autoreleasepool{} 将代码环绕即可。 原理那么系统是如何实现 Autorelease 的，在 ARC 下，我们使用 @autoreleasepool{} 来使用一个 AutoreleasePool，随后编译器将其改写成下面的样子： 123void *context = objc_autoreleasePoolPush();// &#123;&#125; 中的代码objc_autoreleasePoolPop(context); 这两个函数都是对 AutoreleasePoolPage 的简单封装，所以自动释放机制的核心就在于这个类。 123456789101112class AutoreleasePoolPage &#123; magic_t const magic; id *next; pthread_t const thread; AutoreleasePoolPage * const parent; AutoreleasePoolPage *child; uint32_t const depth; uint32_t hiwat; // other code ...&#125; AutoreleasePoolPage 是一个 C++ 实现的类。 AutoreleasePool 并没有单独的结构，而是由若干个 AutoreleasePoolPage 以双向链表的形式组合而成（分别对应结构中的 parent 指针和 child 指针） AutoreleasePool 是按线程一一对应的（结构中的 thread 指针指向当前线程） AutoreleasePoolPage 每个对象会开辟 4096 字节内存（也就是虚拟内存一页的大小），除了上面的实例变量所占空间，剩下的空间全部用来储存 autorelease 对象的地址 上面的 id *next 指针作为游标（哨兵对象）指向栈顶最新 add 进来的 autorelease 对象的下一个位置 一个 AutoreleasePoolPage 的内存被占满时，会新建一个 AutoreleasePoolPage 对象，连接链表，后来的 autorelease 对象会被添加到新的 page 中 所以，若当前线程中只有一个 AutoreleasePoolPage 对象，并记录了很多 autorelease 对象地址，如下图： 图中的情况，这一页再加入一个 autorelease 对象就要满了（也就是 next 指针马上指向栈顶），这时就要执行上面说的操作，建立下一页 page 对象，与这一页链表连接完成后，新的 page 的 next 指针被初始化在栈底（begin 的位置），然后继续向栈顶添加新对象。 所以，向一个对象发送 autorelease 消息，就是将这个对象加入到当前的 AutoreleasePoolPage 的栈顶 next 指针指向的位置。 每当进行一次 objc_autoreleasePoolPush 调用时，runtime 向当前的 AutoreleasePoolpage 中 add 进一个 哨兵对象，值为 0（也就是个 nil），那么这一个 page 就变成了下面的样子： objc_autoreleasePoolPush 的返回值正是这个哨兵对象的地址，被 objc_autoreleasePoolPop(哨兵对象) 作为入参，所以： 根据传入的哨兵对象地址找到哨兵对象所处的 page 在当前 page 中，将晚于哨兵对象插入的所有 autorelease 对象都发送一次 -release 消息，并向回移动 next 指针到正确位置，从最新加入的对象一直向前清理，可以向前跨越若干个 page，直到哨兵对象所在的 page 刚才的 objc_autoreleasePoopPop 执行后，最终变成了下面的样子： 知道了上面的原理，嵌套的 AutoreleasePool 就非常简单了，pop 的时候总会释放到上次 push 的位置，多层的 pool 就是多个哨兵对象而已，就像剥洋葱一样，每次一层，互不影响。 在对象的引用计数归零时，会调用 dealloc 方法回收对象。 原理部分的讲解来自于孙源大神的 黑幕背后的Autorelease，讲的非常好，大家可以看看。 另外说一下 ARC 中对 autorelease 和 retain 的一些优化： 如果 ARC 在运行时检测到类函数中的 autorelease 后紧跟着一个 retain 操作，此时不直接调用对象的 autorelease 方法，而是改为调用 objc_autoreleaseReturnValue。objc_autoreleaseReturnValue 会检视当前方法返回之后将要执行的那段代码，若那段代码要在返回对象上执行 retain 操作，则设置全局数据结构中的一个标志位，而不执行 autorelease 操作，与之相似，如果方法返回了一个自动释放的对象，而调用方法的代码要保留此对象，那么此时不直接执行 retain，而是改为执行 objc_retainAutoreleasedReturnValue 函数。此函数要检测刚才提到的标志位，若已经置位，则不执行 retain 操作，设置并检测标志位，要比调用 autorelease 和 retain 更快。 dealloc当对象的引用计数为 0 时，也就是对象的所有者都不持有该对象，该对象被废弃时，不管 ARC 是否有效，都会调用对象的 dealloc 方法，对对象进行析构。 简单列举一下 dealooc 的调用流程，大家可以结合 runtime 源码来看： dealloc 调用流程 首先调用 _objc_rootDealloc() 接下来调用 rootDealloc() 这时候会判断是否可以被释放，判断的依据主要有 5 个： NONPointer_ISA // 是否是非指针类型 isa weakly_reference // 是否有若引用 has_assoc // 是否有关联对象 has_cxx_dtor // 是否有 c++ 相关内容 has_sidetable_rc // 是否使用到 sidetable 如果没有之前 5 种情况的任意一种，则可以执行释放操作，C 函数的 free() 执行完毕 objc_dispose() 调用流程 直接调用 objc_destructInstance() 之后调用 C 函数的 free() objc_destructInstance() 调用流程 先判断 hasCxxDtor，如果有 c++ 相关内容，要调用 object_cxxDestruct()，销毁 c++ 相关内容 再判断 hasAssociatedObjects，如果有关联对象，要调用 object_remove_associations()，销毁关联对象的一系列操作 然后调用 clearDeallocating() 执行完毕 clearDeallocating() 调用流程 先执行 sideTable_clearDeallocating() 再执行 waek_clear_no_lock，将指向该对象的弱引用指针置为 nil 接下来执行 table.refcnts.eraser()，从引用计数表中擦除该对象的引用计数 至此为此，dealloc 的执行流程结束 总结来做一个小总结吧。 内存分区： 栈区 堆区 全局区 未初始化 已初始化 常量区 代码区 内存管理方式： Tagged Pointer（小对象） NONPOINTER_ISA （指针中存放与该对象内存相关的信息） 散列表（引用计数表、弱引用表） 这篇文章讲了内存分区、内存管理方式、SideTables 原理、引用计数、alloc/retain/release/autorelease/dealloc 内存相关方法的介绍，以及自动释放池。 参考文章【iOS】内存五大区域 深入浅出－iOS内存分配与分区 理解 iOS 的内存管理 深入理解 GCD iOS底层探索 - 实例对象的创建 神经病院 Objective-C Runtime 入院第一天 iOS 开发笔记（七）: 深入理解 Autorelease 黑幕背后的Autorelease ARC下dealloc过程及.cxx_destruct的探究 详解iOS内存管理机制内部原理]]></content>
      <categories>
        <category>iOS概念攻坚之路</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>Objective-c</tag>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS概念攻坚之路（二）：Runtime]]></title>
    <url>%2F2019%2F05%2F20%2FiOS%E6%A6%82%E5%BF%B5%E6%94%BB%E5%9D%9A%E4%B9%8B%E8%B7%AF%2F%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9ARuntime%2F</url>
    <content type="text"><![CDATA[前言这年头，不能扯点 Runtime 哪敢去面试啊。。 Runtime 直接翻译就是 运行时。但是有人说它叫运行时，有人说它是运行时库，有人说它就是一个对象，exm？又是对象？当初我看 RunLoop 的时候你也是这么说的。但你说的是对的，毕竟万物皆对象嘛，好，你回去等通知吧。 我觉得有几个概念要提前简单说明一下： 编译时：代码编译的时候 运行时：程序运行的时候 运行时库：程序运行的时候所依赖的库 运行时系统：一种把半编译的运行码在目标机器上运行的环境（维基百科），可以简单理解为一种运行环境 这里可以看看这位知乎er的回答。 运行时就是程序运行的时候。 运行时库就是程序运行的时候所依赖的库。运行的时候指的是指令加载到内存并由 CPU 执行的时候。C 代码编译成可执行文件的时候，指令没有被 CPU 执行，这个时候算是编译时，就是编译的时候。 什么是 Runtime我们 iOSer 说的 Runtime 都是指 Objective-C 语言中的 Runtime。我们先来看看官方是怎么定义 Runtime 的： Objective-C 是一门动态语言，它将很多静态语言在编译和链接时做的事情推迟到运行时来处理。 这种特性意味着 Objective-C 不仅需要一个编译器，还需要一个运行时系统来执行编译的代码。对于 Objective-C 来说，这个运行时系统就像一个操作系统一样：它让所有的工作可以正常的运行。 那么 Objective-C 是如何实现这个运行时系统的呢？其实就是使用 C 和汇编写的一个运行时库，也就是我们常说的 Runtime，正是因为有这个运行时库，我们所编写的代码才能够正常的运行。 所以 Runtime 其实指的是那个用 C 和汇编写的那个库，库这个概念呢可以简单的理解成我们平时用的一些第三方库，比如 AFNetworking，我们开发需要网络请求，所以我们引入了 ADNetworking 库，而 Objective-C 语言需要动态性，所以引入了 Runtime 库。 不过一般我们说 Runtime，不但包含运行时库的意思，还包含了运行时、运行时系统等一些概念，这样比较笼统，不过个人觉得也无伤大雅，毕竟万物皆对象嘛。。 这里我还想扯一下一个问题，那就是，程序是从 main 函数开始的吗？这是《程序员的自我修养——链接、装载与库》里面的一个问题（书318页）。 我们一般都说 “程序的入口函数 main”，但是如果你善于观察，就会发现当程序执行到 main 函数的第一行时，很多事情都已经完成了。 这是 Objective-C 的 main.m 文件中的 main 函数，也就是我们一般说的程序入口。 12345int main(int argc, char * argv[]) &#123; @autoreleasepool &#123; return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class])); &#125;&#125; 如果我们打断点到函数里面，会发现在程序刚刚执行 main 的时候，main 函数的两个参数（argc 和 argv）已经被正确传了进来。此外，在你不知道的时候，堆和栈的初始化悄悄完成了，一些系统 I/O 也被初始化了，也许还有一些其他的操作，所以，main 函数执行之前其实系统已经帮我们做了一些事情。这是如何实现的呢？ 操作系统装载程序之后，首先运行的代码并不是 main 的第一行，而是某些别的代码，这些代码负责准备好 main 函数执行所需要的环境，并且负责调用 main 函数，这时候你才可以在 main 函数里放心大胆地写各种代码，申请内存、使用系统调用、触发异常、访问 I/O。在 main 返回之后，它会记录 main 函数的返回值，然后结束进程。 运行这些代码的函数称为 入口函数 或 入口点（Entry Point），视平台的不同而有不同的名字。程序的入口点实际上是一个程序初始化和结束部分，它往往是运行库的一部分。一个典型的程序运行步骤大致如下： 操作系统在创建进程后，把控制权交到了程序的入口，这个入口往往是运行库中的某个入口函数 入口函数对运行库和程序运行环境进行初始化，包括堆、I/O、线程、全局变量构造，等等 入口函数在完成初始化后，调用 main 函数，正式开始执行程序主体部分 main 函数执行完毕以后，返回到入口函数，入口函数进行清理工作，包括全局变量析构、堆销毁、关闭 I/O 等，然后进行系统调用结束进程 这边多加了一个概念，运行库，这个运行库其实在 Objective-C 中就是运行时库，我们的主角：Runtime。 再重复一下，Runtime 就是 Objective-C 中使用 C 和 汇编编写的一套运行时库，它是我们代码真正运行的环境。 Runtime 结构这里有一份编译好的 Runtime 源码。当然也可以从 opensource.apple 下载，目前最新的版本是 objc4-750，我们就使用这个版本来看一下 Runtime 里面的一些重要结构和函数。 先列举一下比较重要的一些基本概念： SEL：方法选择器，全名是 selector id：是一个参数类型，指向某个类实例的指针 Class：指向了 objc_class 结构体的指针 Method：代表了类中的某个方法的类型 Ivar：成员变量的类型 IMP：函数指针，由编译器生成，方法实现的代码就是由 IMP 指定 Cache：方法调用的缓存器，为方法调用的性能进行优化 Property：属性存储器 Class来看一下小码哥的一张图： 从源码分析一下： 123456789101112131415typedef struct objc_object *id;typedef struct objc_class *Class;struct objc_object &#123; isa_t isa;&#125;;struct objc_class : objc_object &#123; // Class ISA; Class superclass; cache_t cache; // 方法缓存 class_data_bits_t bits; // 用于获取具体的类信息 ...&#125; 因为 objc_class 继承于 objc_object，所以 objc_class 的结构其实是： 1234567struct objc_class : objc_object &#123; isa_t isa; Class superclass; cache_t cache; // 方法缓存 class_data_bits_t bits; // 用于获取具体的类信息 ...&#125; objc_object 用来描述 OC 中的实例，当用口语描述实例时，总会说 「XX类的实例x」或「x是XX的实例」；objc_object 的 isa 在程序结构上表达类似的含义，它指向了该实例所对应的类，类在 runtime 中被描述成 objc_class 结构。 objc_class 继承自 objc_object，所以它也有 isa 指针，指向它的元类，对于元类而言，类本身也是一个对象；objc_class 的 superclass 成员变量指向该类的父类；isa 和 superclass 这两个成员变量在继承链中扮演者关键作用，满足了类的继承关系的构建。关于 isa、superclass和元类的关系会在本文后面详细说明。cache 成员变量和优化有关，譬如缓存最近命中的方法等。对于 bits 字段，通过它，可以找到类的其他描述信息，包括类名、方法、成员变量等。 bits 类型的 class_data_bits_t 是一个结构体，里面包含了一个 class_rw_t 类型的指针，叫 data。class_rw_t 内部有个 class_ro_t 的指针，叫 ro。 objc_object 与 isa12345struct objc_object &#123; Class isa;&#125;typedef struct objc_object *id; objc_object 中只有一个 isa，所以我们直接来看 isa，它对应的类型是 isa_t，是一个联合体，在 x86_64 架构下的定义如下： 123456789101112// 只抽取重要的部分struct &#123; uintptr_t nonpointer : 1; // 0:普通指针，1:优化过，使用位域存储更多信息 uintptr_t has_assoc : 1; // 对象是否含有或曾经含有关联引用 uintptr_t has_cxx_dtor : 1; // 表示是否有C++析构函数或OC的dealloc uintptr_t shiftcls : 44; // 存放着 Class、Meta-Class 对象的内存地址信息 uintptr_t magic : 6; // 用于在调试时分辨对象是否未完成初始化 uintptr_t weakly_referenced : 1; // 是否被弱引用指向 uintptr_t deallocating : 1; // 对象是否正在释放 uintptr_t has_sidetable_rc : 1; // 是否需要使用 sidetable 来存储引用计数 uintptr_t extra_rc : 8; // 引用计数能够用 8 个二进制位存储时，直接存储在这里&#125;; 在 64 位架构下，系统用八个字节也就是 64 个二进制位来存储一个 isa，而如果单纯的存储对象的内存地址，那么其实不需要那么多位，剩余的二进制位就会浪费，所以苹果将剩余的二进制位来存储该对象相关的一些内存信息，这也是对内存使用的一个优化。 在 Objective-C 中，所有的类自身也是一个对象，这个对象的 Class 里面也有一个 isa 指针，它指向 metaClass(元类)，在后面我们会介绍。 当我们向一个 Objective-C 对象发送消息时，运行时库到对象的 isa 指针所指向的类中的方法列表以及父类的方法列表中去寻找与消息对应的 selector 指向的方法，能找到就执行，不能就进行消息转发。 superclass指向该类的父类，如果该类已经是最顶层的根类（如 NSObject 或 NSProxy），则 superclass 为 NULL。 元类 (Meta Class)来看一个例子： 1NSArray *array = [NSArray array]; 这个例子中，+array 消息发送给了 NSArray 类，而这个 NSArray 也是一个对象。既然是对象，那么它也是一个 objc_object 指针，它包含一个指向其类的 isa 指针。那么就有一个问题了，这个 isa 指向的是什么呢？为了调用 +array 方法，这个类的 isa 指针必须指向一个包含这些类方法的一个 objc_class 结构体。这就引出了 meta-class 的概念。 meta-class 是一个类对象的类。 当我们向一个对象发送消息时，Runtime 会在这个对象所属的这个类的方法列表中查找方法；而向一个类发送消息时，会在这个类的 meta-class 的方法列表中查找。 meta-class 之所以重要，是因为它存储着一个类的所有类方法。每个类都会有一个单独的 meta-class，因为每个类的类方法基本不可能完全相同。 再深入一下，既然 meta-class 也是一个类，也可以向它发送一个消息，那么它的 isa 又是指向什么呢？为了不让这种结构无限延伸下去，Objective-C 的设计者让所有的 meta-class 的 isa 指向基类的 meta-class，以此作为它们的所属类。即，任何 NSObject 继承体系下的 meta-class 都使用 NSObject 的 meta-class 作为自己所属的类，而基类的 meta-class 的 isa 指向它自己，这样就形成了一个完美的闭环。 这个结构我们看一下这张很经典的图： cache_tcache_t 的定义： 1234567891011struct cache_t &#123; struct bucket_t *_buckets; // 散列表 mask_t _mask; // 散列表的长度 -1 mask_t _occupied; // 已经缓存的方法数量&#125;// bucket_tstruct bucket_t &#123; cache_key_t _key; // SEL 作为 key IMP _imp; // 函数的内存地址&#125; buckets:指向 Method 数据结构指针的数组。这个数组可能包含不超过 mask+1 个元素。需要注意的是，指针可能是 NULL，表示这个缓存 bucket 没有被占用，另外被占用的 bucket 可能是不连续的。这个数组可能会随着时间而增长。 mask:一个整数，指定分配的缓存 bucket 的总数。在方法查找过程中，Objective-C runtime 使用这个字段来确定开始线性查找数组的索引未知。指向方法 selector 的指针与该字段做一个 AND 位操作（index = (mask &amp; selector)）。这可以作为一个简单的 hash 散列算法。 occupied:一个整数，指定实际占用的缓存 bucket 的总数。 所以 cache_t 是一个 散列表 （想贴维基百科的，但是考虑到要科学上网就贴一下百度的吧），用来缓存曾经调用过的方法，可以提高方法的查找速度。 class_data_bits_t上面说过，class_data_bits_t 是一个结构体，里面包含了一个 class_rw_t 类型的指针，叫 data。class_rw_t 内部有个 class_ro_t 的指针，叫 ro。 我们来看一下 class_rw_t 和 class_ro_t，这两个都是包含类信息的一个结构体，rw 意为 read-write，ro 意为 read-only。也就是 class_rw_t 是可读写的，而 class_ro_t 是只读的，下面是它们具体的定义： class_ro_t 的定义： 12345678910struct class_ro_t &#123; const char * name; // 类名 method_list_t * baseMethodList; // 方法列表 protocol_list_t * baseProtocols; // 协议列表 const ivar_list_t * ivars; // 实例变量 ...&#125;; class_rw_t 的定义： 123456789101112struct class_rw_t &#123; const class_ro_t *ro; // 原始类信息 method_array_t methods; // 类列表 property_array_t properties; // 属性列表 protocol_array_t protocols; // 协议列表 Class firstSubclass; // 第一个子类 Class nextSiblingClass; // 兄弟类 &#125; 在编译阶段，编译器就对 OC 类结构的基本信息进行了整理，只是这些信息比较分散，libojc 在运行时阶段，将这些零散的信息提取出来进行再加工结构化。 那么为什么要设计 class_rw_t 和 class_ro_t 两个结构体呢？它们又是如何初始化的呢？ 这篇文章 指出，objc_class 的 data 指针最开始指向 class_ro_t 结构体，但在 realize 逻辑中，libobjc 创建了一个 class_rw_t 结构体，并把 data 指针指向到该结构体。 realize: OC 类在被使用之前（譬如调用类方法），需要进行一系列的初始化，譬如：指定 superclass、指定 isa 指针、attach categories 等等；libobjc 在 runtime 阶段就可以做这些事情，但是有些过于浪费，更好的选择是懒处理，这一举措极大优化了程序的执行速度。而 runtime 把对类的惰性初始化过程称为「realize」。 利用已经被 realize 的类含有 RW_REALIZED 和 RW_REALIZING 标记的特点，可以为项目找出无用类；因为没有被使用的类，一定没有被 realized。 至于为什么要设计，可以这么理解，class_ro_t 包含的类信息（方法、属性、协议等）都是在编译期就可以确定的，暂且称为元信息吧，在之后的逻辑中，它们显然是不希望被改变的；后续在用户层，无论是方法还是别的扩展，都是在 class_rw_t 上进行操作，这些操作都不会影响类的元信息。 来看一下小码哥的关于 class_rw_t 和 class_ro_t 的结构的图，画的好的我就不重新画了（就没重新画过，忽略我）。 注意到 class_rw_t 中的 method_array_t，它是一个数组，而它里面的 method_list_t，也是一个数组，为什么我们需要用一个二维数组来保存方法呢？像 class_ro_t 中那样不就好了吗？这是因为，我们都知道 OC 中有分类的概念，分类中可以为原来的类去添加新方法，而且一个类是可以有多个分类的。那么每个分类的方法列表对应一个 method_list_t，最终都合并到原来的类的 method_array_t 中去。 method_tmethod_t 定义： 1234567891011struct method_t &#123; SEL name; // 函数名 const char *types; // 编码（返回值类型、参数类型） IMP imp; // 指向函数的指针（函数地址）&#125;;// IMPtypedef id _Nullable (*IMP)(id _Nonnull, SEL _Nonnull, ...);// SELtypedef struct objc_selector *SEL; SEL 代表方法\函数名，一般叫做选择器，底层结构跟 char * 类似 可以通过 @selector() 和 sel_registerName() 获得 可以通过 sel_getName() 和 NSStringFromSelector() 转成字符串 不同类中相同方法的名字，所对应的方法选择器是相同的 types 包含了函数返回值，参数编码的字符串，关于编码字符串对应的意义，可以查看这里。 我们可以看到结构体中包含一个 SEL 和 IMP，实际上相当与 SEL 和 IMP 之间做了一个映射。有了 SEL，我们便可以找到对应的 IMP，从而调用方法的实现代码。 我觉得关于结构就说到这里吧，大家可以下载编译好的源码 ojc4-750 看看。 另外也可以看看这篇文章 runtime 完整总结。里面详细介绍了 runtime 的结构和一些概念，虽然版本有点久，但是还是有参考价值。 Runtime 的作用Runtime 其实主要做了下面几件事情： 封装：在这个库中，对象可以用 C 语言中的结构体表示，而方法可以用 C 函数来实现，另外再加上了一些额外的特性。这些结构体和函数被 runtime 函数封装后，我们就可以在程序运行时创建、检查、修改类、对象和它们的方法了。 找出方法的最终执行代码：当程序中执行 [receiver message] 时，会向消息接收者（receiver）发送一条消息 message，runtime 会根据消息接收者是否能响应该消息而做出不同的反应，这里面涉及到了消息转发，我们待会讲。 OC 中大致分为三类对象： 实例对象 类对象 元类对象 它们通过 isa 彼此串联，实例对象的 isa 指向类对象，类对象的 isa 指向元类对象，元类对象的 isa 指向元类的根类，它们之间的关系可以看一下上面 元类 (meta-class) 部分的那张图，消息也是沿着图中的指向来进行传递的。 消息与消息转发可以看一下YY大佬的 Objective-C 中的消息与消息转发。 1.编译器的转换1[reveiver message]; 这一句话的含义是：向 receiver 发送名为 message 的消息。 我们可以把 oc 的代码转换成 c 代码，会发现 [reveiver message] 会由编译器转化为以下的纯 C 调用。 1objc_msgSend(receiver, @selector(message)); 所以，objc 发送消息，最终大都会转换为 objc_msgSend 的方法调用。 苹果在 文档 里是这么写的： 1id objc_msgSend(id self, SEL _cmd, ...); 将一个消息发送给一个对象，并且返回一个值。 在 objc 中，每个方法都默认带了两个参数，一个是 self，方法的调用者；另一个是 _cmd，当前方法的 selector。 其中 self 是消息的接收者，_cmd 是 @selector，... 是可变参数列表。 向一般对象发送消息：调用 objc_msgSend 向 super 发送消息：调用 objc_msgSendSuper 返回值是一个结构体：调用 objc_msgSend_stret 或 objc_msgSendSuper_stret。 2.运行时定义的数据结构123456789101112typedef struct objc_class *Class;typedef struct objc_object *id;struct objc_object &#123; Class isa;&#125;/// 不透明结构体，selectortypepef struct objc_selector *SEL;/// 函数指针，用于表示对象方法的实现typedef id (*IMP)(id SEL, ...); id 指代 objc 中的对象，每个对象在内存的结构并不是确定的，但其首地址指向的肯定是 isa。通过 isa 指针，运行时就能获取到 objc_class。 objc_class 表示对象的 Class，它的结构是确定的，由编译器生成。 SEL 表示选择器，这是一个不透明结构体，但是实际上，通常可以把它理解为一个字符串。例如 printf(&quot;%s&quot;,@selector(isEqual:)) 会打印出 isEqual。运行时维护着一张 SEL 的表，将相同字符串的方法名映射到唯一一个 SEL。通过 sel_registerName(char *name) 方法，可以查找到这张表中方法名对应的 SEL。苹果提供了一个语法糖 @selector 用来方便地调用该函数。 实际上消息发送，最终都会转换成调用 C 函数。objc_msgSend 的实际动作就是，找到这个函数指针，然后调用它。 3.objc_msgSend 的动作为了加快速度，苹果对这个方法做了很多优化，这个方法是用汇编实现的。下面是 objc_msgSend 的方法实现的伪代码，来自 这里： 12345678910111213141516171819202122232425262728293031323334id objc_msgSend(id self, SEL op, ...) &#123; if (!self) return nil; // 关键代码(a) Imp imp = class_getMethodImplementation(self-&gt;isa, SEL op); imp(self, op, ...); // 调用这个函数，伪代码...&#125;// 查找 IMPIMP calss_getMethodImplementation(Class cls, SEL self) &#123; if (!cls || !sel) return nil; IMP imp = lookUpImpOrNil(cls, sel); if (!imp) &#123; ... // 执行动态绑定 &#125; IMP imp = lookUpOrNil(cls, sel); if (!imp) return _objc_msgForward; // 这个用于消息转发的 return imp;&#125;// 遍历继承链，查找 IMPIMP lookUpImpOrNil(Class cls, SEL sel) &#123; if (!cls-&gt;initialize()) &#123; _class_initialize(cls); &#125; Class curClass = cls; IMP imp = nil; do &#123; // 先查缓存，缓存没有时重建，仍旧没有则向父类查询 if (!curClass) break; if (!curClass-&gt;cache) fill_cache(cls, curClass); imp = cache_getImp(curClass, sel); if (imp) break; &#125; while (curClass = curClass-&gt;superclass); // 关键代码(b) return imp;&#125; objc_msgSend 的动作比较清晰：首先在 Class 中的缓存查找 imp（没缓存则初始化缓存），如果没找到，则向父类的 Class 查找。如果一直查到到根类仍旧没有实现，则用 _objc_msgForward 函数指针代替 imp。最后，执行这个 imp。 _objc_msgForward 是用于消息转发的，当方法没有被寻找到的时候，就会触发消息转发流程。 4.消息转发当一个对象能接收一个消息时，就会走正常的方法调用流程。但如果一个对象无法接收指定消息时，又会发生什么事呢？默认情况下，如果是以 [receiver message] 的方式调用方法，那么如果 receiver 无法响应 message 消息时，编译器就会报错。但如果是 perform... 的形式来调用，则需要等到运行时才能确定 receiver 是否能接受 message 消息。如果不能，则程序崩溃。 通常，当我们不能确定一个对象是否能接收某个消息时，会先调用 respondsToSelector: 来判断一下： 123if ([self respondsToSelector:@selector(method)]) &#123; [self performSelector:@selector(method)];&#125; 不过，我们不讨论使用 respondsToSelector: 判断的情况，这才是我们的重点。 当一个对象无法接收某一消息时，就会启动所谓的 消息转发（message forwarding） 机制，通过这一机制，我们可以告诉对象如何处理未知的消息。默认情况下，对象接收到未知的消息，会导致程序崩溃。 那我们来正式说一下 消息转发 的流程，可以分为三个阶段： 方法解析 重定向 消息转发 来看一下这三个阶段具体做的事情： 1.方法解析当 runtime 在方法缓存列表和方法分发列表（包括超类）中找不到要执行的方法时，首先会进入方法解析阶段，此时可以在方法解析中动态添加方法实现。具体来看是两个方法：+resolveInstanceMethod: 和 +resolveClassMethod:，分别对应实例方法和类方法找不到实现的情况，我们可以在方法解析中动态添加方法实现。 如下面这个例子： 12345678910111213141516171819202122232425262728293031323334353637383940#import "ViewController.h"#import &lt;objc/runtime.h&gt;@interface ViewController ()- (void)methodWithoutImplementation; // 定义一个没有实现的方法@end@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; [self methodWithoutImplementation]; // 调用没有实现的方法&#125;/** 动态添加的方法（OC 的方法其实只是一个 C 函数，不过它默认带了两个参数，一个是 id self. 另外一个是 SEL _cmd） */void resolveMethod(id self, SEL _cmd) &#123; NSLog(@"%s",__func__);&#125;/** runtime 调用方法解析 @param sel 方法的 selector @return NO：解析方法失败，YES：已处理 */+ (BOOL)resolveInstanceMethod:(SEL)sel &#123; if (sel == @selector(methodWithoutImplementation)) &#123; class_addMethod([self class], sel, (IMP)resolveMethod, "v@:"); return YES; &#125; return [super resolveInstanceMethod:sel];&#125;@end 可以看到主要是根据 sel 去判断当前需要解析的方法是哪一个，然后通过 class_addMethod:::: 方法去动态添加一个方法，我们来看一下 class_addMethod:::: 的定义： 1class_addMethod(Class cls, SEL name, IMP imp, const char *types); 我们分别来看一下这四个参数对应的意思： Class cls : 这是你要指定的类，runtime 会到这个类中去找方法 SEL name : 这是要解析的那一个方法 IMP : 这是动态添加的方法实现的 imp const char *types : 类型编码，是个字符串（更多关于类型编码） 如果你想让转发过程继续，那么就让 resolveInstnceMethod: 返回 NO。 2.重定向在消息转发机制执行前，系统会再给我们一次偷梁换柱的机会，即通过重载 -(id)forwardingTargetForSelector:(SEL)sel 方法替换消息的接受者为其他对象，毕竟消息转发需要耗费更多的时间，抓住这次机会将消息重定向给别人是个不错的选择，如果此方法返回 nil 或是 self，则会进入消息转发阶段，否则将会向返回的对象重新发送消息（其实这一步也可以算入转发阶段，因为重定向会将消息「转发」给另一个对象，不过为了方便理解，所以我们称其为 「重定向」）。 来看一下下面这个例子： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#import "ViewController.h"@interface RedirectB : NSObject- (void)redirectMethod;@end@implementation RedirectB- (void)redirectMethod &#123; NSLog(@"%s",__func__);&#125;@end@interface RedirectA : NSObject- (void)redirectMethod;@end@implementation RedirectA- (id)forwardingTargetForSelector:(SEL)aSelector &#123; NSString *selStr = NSStringFromSelector(aSelector); if ([selStr isEqualToString:@"redirectMethod"]) &#123; return [RedirectB new]; &#125; return [super forwardingTargetForSelector:aSelector];&#125;@end@interface ViewController ()@end@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; RedirectA *a = [RedirectA new]; [a redirectMethod]; redirectMethod &#125;@end 在 RedirectA 中定义了一个没有实现的方法，在 viewDidLoad() 方法中调用，按照正常的逻辑，这样会造成程序崩溃。但是我们在 RedirectA 中实现了 forwardingTargetForSelector: 方法，将 redirectMethod 这个方法的消息转发给了 RedirectB，在 RedirectB 中我们实现了这个方法，所以可以看到控制台的打印： 1-[RedirectB redirectMethod] 使用这个方法通常是在对象内部（本例中就是 RedirectA 的内部），可能还有一系列其他对象能处理该消息，我们便可借这些对象来处理消息并返回，这样在对象外部看来，还是由该对象处理了这一消息。 这样我们就完成了消息的重定向过程，也就是一个对象无法识别的消息，我们将其转发给另外一个对象。那么我们来看一下最后的一个步骤，消息转发。 3.消息转发如果重定向还不能处理未知的消息，那么就会启动消息转发，此时会调用以下方法： 1- (void)forwardInvocation:(NSInvocation *)anInvocation 运行时系统会在这一步给消息接收者最后一次机会将消息转发给其他对象。对象会创建一个表示消息的 NSInvocation 对象，把与尚未处理的消息有关的全部细节都封装在 anInvocation 中，包括 selector、目标（target）和参数。 forwardInvocation: 方法的实现主要有两个任务： 定位可以响应封装在 anInvocation 中的消息的对象，这个对象不需要能处理所有未知消息。 使用 anInvocation 作为参数，将消息发送到选中的对象。anInvocation 将会保留调用结果，运行时系统会提取这一结果并将其发送到消息的原始发送者。 不过，在这个方法中可以实现一些更复杂的功能，我们可以对消息的内容进行修改，比如追回一个参数，然后再去触发消息。另外，若发现某个消息不应由本类处理，则应调用父类的同名方法，以便继承体系中的每个类都有机会处理此调用请求。 这个方法就像是一个那些不能被识别的消息的分发中心，它可以将这些消息转发给不同的对象，也可以将一个消息翻译成另外的一个消息。或者简单的吃掉某些消息，因此没有响应也没有错误。它也可以对不同的消息提供相同的响应，这一切都取决于方法的具体实现，该方法提供的是将不同对象连接到消息链的能力。 不过在此之前，我们必须重写以下方法： 1- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector 需要从上面的这个方法中获取的信息来创建 NSInvocation 对象，因此我们必须重写这个方法，为给定的 selector 提供一个合适的方法签名。 我们来看一个完整的示例： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#import "ViewController.h"@interface ForwardB : NSObject- (void)forwardMethod;@end@implementation ForwardB- (void)forwardMethod &#123; NSLog(@"%s",__func__);&#125;@end@interface ForwardA : NSObject- (void)forwardMethod;@end@implementation ForwardA- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector &#123; // 获取 aSelector 的方法签名 NSMethodSignature *signature = [super methodSignatureForSelector:aSelector]; if (!signature) &#123; // 如果无法获取 if ([ForwardB instancesRespondToSelector:aSelector]) &#123; // 看 ForwardB 是否能够响应 aSelector // 获取 ForwardB 中 aSelector 的方法签名 signature = [ForwardB instanceMethodSignatureForSelector:aSelector]; &#125; &#125; return signature;&#125;- (void)forwardInvocation:(NSInvocation *)anInvocation &#123; if ([ForwardB instancesRespondToSelector:anInvocation.selector]) &#123; [anInvocation invokeWithTarget:[ForwardB new]]; &#125;&#125;@end@interface ViewController ()@end@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; ForwardA *a = [ForwardA new]; [a forwardMethod];&#125;@end NSObject 的 forwardInvocation: 方法只是简单调用了 doesNotRecognizeSelector: 方法，它不会转发任何消息。这样，如果不在以上所述的三个步骤中处理未知消息，则会引发一个异常。 小结： 在找不到方法实现的时候，首先会进入方法解析阶段，我们在方法解析中动态添加方法实现。如果在方法解析阶段中我们没有处理这条消息，那系统会给我们一次重定向的机会。msgSend 方法需要指定一个 target，重定向的意思就是你当前的 target 实现不了，那么我将这个消息转发给另一个 target 去实现，对应的方法是 forwardingTargetForSelector:。如果重定向阶段也没有找到实现，那么就正式进入消息转发阶段。在消息转发阶段需要重写两个方法，一个是获取方法签名的方法 methodSignatureForSelector:、另一个是 forwardInvocation 方法。methodSignatureForSelector: 如果返回 nil，那么转发流程就会终止。forwardInvocation: 是消息转发的最后一关，这个方法就像是一个那些不能被识别的消息的分发中心，它可以将这些消息转发给不同的对象，也可以将一个消息翻译成另外的一个消息。或者简单的吃掉某些消息，因此没有响应也没有错误。它也可以对不同的消息提供相同的响应，这一切都取决于方法的具体实现。该方法提供的是将不同对象连接到消息链的能力。如果在这个阶段还不处理消息，那么就会系统就会通过 doneNotRecognizeSelector 抛出异常，程序终止。 贴一下Objective-C 消息发送与转发机制原理 的一张完整消息发送与转发的流程图： 关于 super在 Objective-C 中，如果我们需要在类的方法中调用父类的方法时，通常都会用到 super，如下所示： 1234567891011@interface MyViewController : UIViewController@end@implementation MyViewController- (void)viewDidLoad &#123; [super viewDidLoad];&#125;@end 我们知道如何使用 super，但现在的问题是，它是如何工作的？ 首先我们要知道 super 与 self 不同，self 是类的一个隐藏参数，每个方法的实现的第一个参数即为 self。而 super 并不是隐藏参数，它实际上只是一个 「编译器标识符」，它负责告诉编译器，当调用 viewDidLoad 方法时，去调用父类的方法，而不是本类的方法。而它与 self 指向的是相同的消息接收者。为了理解这一点，我们先来看看 super 的定义： 1234struct objc_super &#123; id receiver; // 即消息的实际接收者 Class super_class; // 指针当前的父类&#125;; 当我们使用 super 来接受消息时，编译器会生成一个 objc_super 结构体。就上面的例子而言，这个结构体的 receiver 就是 MyViewController 对象，与 self 相同；super_class 指向 MyViewController 的父类 UIViewController。 接下来，发送消息时，不是调用 objc_msgSend 函数，而是调用 objc_msgSendSuper 函数，其声明如下： 1id objc_msgSendSuper ( struct objc_super *super, SEL op, ... ); 该函数第一个参数即为前面生成的 objc_super 结构体，第二个参数是方法的 selector。该函数的实际操作是：从 objc_super 结构体指向的 super_class 的方法列表开始查找 viewDidLoad 的 selector，找到后以 objc_receiver 去调用这个 selector，而此时的操作流程就是如下方式了： 1objc_msgSend(objc_super-&gt;receiver, @selector(viewDidLoad)) 由于 objc_super-&gt;receiver 就是 self 本身，所以该方法实际与下面这个调用是相同的： 1objc_msgSend(self, @selector(viewDidLoad)) 为了便于理解，我们看以下例子： 1234567891011121314151617181920212223242526272829@interface MyClass : NSObject- (void)test;@end@implementation MyClass- (void)test &#123; NSLog(@"self class is : %@", self.class); NSLog(@"super class is : %@", super.class);&#125;@end@interface ViewController ()@end@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; MyClass *myClass = [MyClass new]; [myClass test];&#125;@end 可以看到打印台的打印： 122019-05-20 11:16:18.510148+0800 test[67484:14868457] self class is : MyClass2019-05-20 11:16:18.510186+0800 test[67484:14868457] super class is : MyClass 从上例中可以看到，两者的输出都是 MyClass。 Method Swizzling关于 「Method Swizzling」可以看一下 这篇文章。 Method Swizzling 是一项异常强大的技术，它允许我们 动态的替换方法的实现，实现 hook 功能，是一种比子类化更加灵活的「重写」方法的方式。 来看一下例子： 写一个 UIViewController 的分类： 12345678910111213141516171819202122232425262728293031#import "UIViewController+Swizzling.h"#import &lt;objc/runtime.h&gt;@implementation UIViewController (Swizzling)+ (void)load &#123; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; Class class = [self class]; SEL originalSelector = @selector(viewWillAppear:); SEL swizzledSelector = @selector(my_viewWillAppear:); Method originalMethod = class_getInstanceMethod(class, originalSelector); Method swizzledMethod = class_getInstanceMethod(class, swizzledSelector); BOOL success = class_addMethod(class, originalSelector, method_getImplementation(swizzledMethod), method_getTypeEncoding(swizzledMethod)); if (success) &#123; class_replaceMethod(class, swizzledSelector, method_getImplementation(originalMethod), method_getTypeEncoding(originalMethod)); &#125; else &#123; method_exchangeImplementations(originalMethod, swizzledMethod); &#125; &#125;);&#125;- (void)my_viewWillAppear:(BOOL)animated &#123; [self my_viewWillAppear:animated]; NSLog(@"%s",__func__);&#125;@end 在 ViewController 中调用： 123456789101112131415161718#import "ViewController.h"#import "UIViewController+Swizzling.h"@interface ViewController ()@end@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad];&#125;- (void)viewWillAppear:(BOOL)animated &#123; [super viewWillAppear:animated];&#125;@end 我们主要关注 +load 方法中的代码，这里面有几个关键点需要引起我们的注意： 为什么是在 +load 方法中实现 「Method Swizzling」 的逻辑，而不是其他的什么方法，比如 +initialize 等？ 为什么 「Method Swizzling」 的逻辑需要用 dispatch_once 来进行调度？ 为什么需要调用 class_addMethod 方法，并且以它的结果为依据分别处理两种不同的情况？ 下面我们就来逐条分析一下： 第一个为什么：+load 和 +initialize 是 Objective-C runtime 会自动调用的两个类方法，但是它们的调用时机是不一样的。+load 方法是在类被加载的时候调用的，而 +initialize 方法是在类或它的子类收到第一条消息之前被调用的，这里所指的消息包括实例方法和类方法调用。也就是说 +initialize 方法是以懒加载的方式被调用的，如果程序一直没有给某个类或它的子类发送消息，那么这个类的 +initialize 方法是永远不会被调用的。此外 +load 方法还有一个非常重要的特性，那就是子类、父类和分类中的 +load 方法的实现是被区别对待的。换句话说在 Objective-C runtime 自动调用 +load 方法时，分类中的 +load 方法并不会对主类中的 +load 方法造成覆盖。综上所述，+load 方法是实现 「Method Swizzling」 逻辑的最佳 「场所」。 第二个为什么：我们上面提到，+load 方法在类加载的时候会被 runtime 自动调用一次，但是它并没有限制程序员对 +load 方法的手动调用，所以我们所能做的就是尽可能的保证程序能够在各种情况下正常运行。 第三个为什么：我们使用 「Method Swizzling」的目的通常都是为了给程序增加功能，而不是完全替换某个功能，所以我们一般都需要在自定义的实现中调用原始的实现。所以这里就会有两种情况需要我们分别进行处理： 第 1 种情况：主类本身有实现需要替换的方法，也就是 class_addMethod 方法返回 NO。这种情况的处理比较简单，直接交换两个方法的实现就可以了： 1234567891011- (void)viewWillAppear:(BOOL)animated &#123; // 先调用原始实现，由于主类本身有实现该方法，所以这里实际调用的是主类的实现 [self my_viewWillAppear:animated]; // 增加的功能 // ...&#125;- (void)my_viewWillAppear:(BOOL)animated &#123; // 主类的实现&#125; 第 2 种情况：主类本身没有实现需要替换的方法，而是继承了父类的实现，即 class_addMethod 方法返回 YES。这时调用 class_getInstanceMethod 函数获取到的 originalSelector 指向的就是父类的方法，我们再通过执行 lass_replaceMethod(class, swizzledSelector, method_getImplementation(originalMethod), method_getTypeEncoding(originalMethod)); 将父类的实现替换到我们自定义的 my_viewWillAppear 方法中，这样就达到了在 my_viewWillAppear 方法的实现中调用父类实现的目的。 1234567891011- (void)viewWillAppear:(BOOL)animated &#123; // 先调用原始实现，由于主类本身并没有实现该方法，所以这里实际调用的是父类的实现 [self my_viewWillAppear:animated]; // 增加的功能 // ...&#125;- (void)my_viewWillAppear:(BOOL)animated &#123; // 父类的实现&#125; runtime 的实际运用关于开发实例，大家可以看一下这篇 Runtime Method Swizzling 开发实例汇总。我这边大概列举一下： 替换 ViewController 生命周期的方法 解决获取索引、添加、删除元素越界崩溃的问题 防止按钮重复暴力点击 全局更换控件初始效果 App 热修复 App 异常占位图通用类封装 全局修改导航栏后退（返回）按钮 最后有什么错误欢迎大家提出，一起讨论一起进步。]]></content>
      <categories>
        <category>iOS概念攻坚之路</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>Objective-c</tag>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS概念攻坚之路（一）：RunLoop]]></title>
    <url>%2F2019%2F05%2F15%2FiOS%E6%A6%82%E5%BF%B5%E6%94%BB%E5%9D%9A%E4%B9%8B%E8%B7%AF%2F%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9ARunLoop%2F</url>
    <content type="text"><![CDATA[前言Y神写的是真的好。这篇文章的大部分内容来自 Y神的深入理解 RunLoop，再结合官方文档 和其他一些网上的资料再加上自己的一些理解做了一些补充和归纳，官方文档也非常值得一看。 RunLoop 简单介绍RunLoop 直接翻译过来就是 运行循环。运行是什么？运行指你的程序运行，循环？额，就是循环。所以运行循环就是指能让你的程序循环不断的运行的一个东西。 RunLoop 是一个让线程能随时处理事件但并不退出的机制。这种模型通常被称为 Event Loop，实现这种模型的关键点在于：如何管理事件/消息，如何让线程在没有处理消息时休眠以避免资源占用、在有消息到来时立刻被唤醒。 所以，RunLoop 实际上就是一个对象，这个对象管理了其需要处理的事件和消息，并提供了一个入口函数来执行上面 Event Loop 的逻辑。线程执行了这个函数后，就会一直处于函数内部 “接受消息-&gt;等待-&gt;处理” 的循环中，直到这个循环结束（比如传入 quit 的消息），函数返回。 至于为什么要有这个 RunLoop，说一个最直接的，iOS 程序启动后运行在主线程上，而线程一般执行完一段任务就会结束，被 CPU 挂起，如果我们没有保住主线程的命，那么我们的 App 一打开就会关闭。所以苹果帮我们在主线程中默认开启 RunLoop，让 App 能够持续运行。 RunLoop 与线程直接列一下两者的关系： RunLoop 与线程是一一对应的。 RunLoop 不允许手动创建，只能通过方法去获取，CFRunLoopGetMain() 和 CFRunLoopGetCurrent()。 RunLoop 是懒加载的，如果你不去使用它，那么它就不会被创建，主线程中的 RunLoop 是苹果帮我们默认开启的。 RunLoop 的销毁发生在线程结束的时候。 RunLoop 与线程的对应关系保存在一个全局的 Dictionary 中 RunLoop 的结构在 Core Foundation 里面关于 RunLoop 有 5 个类： CFRunLoopRef CFRunLoopModeRef CFRunLoopSourceRef CFRunLoopTimeRef CFRunLoopObserverRef 每个 RunLoop 中包含若干个 Mode，每个 Mode 中包含若干个 Source/Observer/Timer。 每次调用 RunLoop 的主函数，都只能指定一种 Mode，指定的 Mode 称为 CurrentMode，如果需要切换 Mode，就只能退出当前 Loop，然后重新更新指定一种 Mode 进入。这样是为了分割不同组的 Source/Observer/Timer，使其互不影响。 CFRunLoopSourceRef 是事件产生的地方。Source 有两个版本：Source0 和 Source1。 Source0 只包含了一个回调（函数指针），它并不能主动触发事件。使用时，你需要先调用 CFRunLoopSourceSignal(source)，将这个 Source 标记为待处理，然后手动调用 CFRunLoopWakeUp(runloop) 来唤醒 RunLoop，让其处理事件。 Source1 包含了一个 mach_port 和一个回调（函数指针），被用于通过内核和其他线程相互发送消息。这种 Source 能主动唤醒 RunLoop 线程。 CFRunLoopTimeRef 是基于时间的触发器，它和 NSTimer 和 toll-free bridged 的，可以混用。其包含一个时间长度和一个回调（函数指针）。当其加入到 RunLoop 时，RunLoop 会注册对应的时间点，当时间点到时，RunLoop 会被唤醒以执行那个回调。 CFRunLoopObserverRef 是观察者，每个 Observer 都包含了一个回调（函数指针），当 RunLoop 的状态发生变化时，观察者都能通过回调接受到这个变化。可以观测的时间点有以下几个： 12345678typedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) &#123; kCFRunLoopEntry = (1UL &lt;&lt; 0), // 即将进入Loop kCFRunLoopBeforeTimers = (1UL &lt;&lt; 1), // 即将处理 Timer kCFRunLoopBeforeSources = (1UL &lt;&lt; 2), // 即将处理 Source kCFRunLoopBeforeWaiting = (1UL &lt;&lt; 5), // 即将进入休眠 kCFRunLoopAfterWaiting = (1UL &lt;&lt; 6), // 刚从休眠中唤醒 kCFRunLoopExit = (1UL &lt;&lt; 7), // 即将退出Loop&#125;; 上面的 Source/Timer/Observer 被统称为 mode item，一个 item 可以被同时加入多个 mode。但一个 item 被重复加入同一个 mode 时是不会有效果的。如果一个 mode 中一个 item 都没有，则 RunLoop 会直接退出，不进入循环。 RunLoop Modes关于具体的结构，大家可以查看 官方文档，里面有一个关于 RunLoop Modes 的列表。 RunLoop 的大致结构： 1234567struct __CFRunLoop &#123; CFMutableSetRef _commonModes; // Set CFMutableSetRef _commonModeItems; // Set&lt;Source/Observer/Timer&gt; CFRunLoopModeRef _currentMode; // Current Runloop Mode CFMutableSetRef _modes; // Set ...&#125;; RunLoop Mode 的大致结构： 12345678struct __CFRunLoopMode &#123; CFStringRef _name; // Mode Name, 例如 @"kCFRunLoopDefaultMode" CFMutableSetRef _sources0; // Set CFMutableSetRef _sources1; // Set CFMutableArrayRef _observers; // Array CFMutableArrayRef _timers; // Array ...&#125;; 大家可以下载 Core Foundation 的源码来查看详细结构。 系统默认注册了 5 个 Mode： kCFRunLoopDefaultMode : App 的默认 Mode，通常主线程是在这个 Mode 下面运行的 UITrackingRunLoopMode : 界面跟踪 Mode，用于 ScrollView 追踪触摸滑动 UIInitializationRunLoopMode : 在刚启动 App 时进入的第一个 Mode，启动完后就不再使用 GSEventReceiveRunLoopMode : 接受系统事件的内部 Mode，通常用不到 kCFRunLoopCommonModes : 这是一个占位的 Mode，没有实际作用 可以点击这里查看更多的苹果内部的 Mode，但那些 Mode 在开发中基本不会遇到。 不同 Mode 之间互不干扰。 我们常用的有两种，kCFRunLoopDefaultMode 和 UITrackingRunLoopMode，还有一个 kCFRunLoopCommonModes，不过 kCFRunLoopCommonModes 只是一种伪模式。 关于 Common modes：一个 Mode 可以将自己标记为 “Common” 属性（通过将其 ModeName 添加到 RunLoop 的 “commonModes” 中）。每当 RunLoop 的内容发生变化时，RunLoop 都会自动将 _commonModeItems 里的 Source/Observer/Timer 同步到具有 “Common” 标记的所有 Mode 里。 视图滑动时定时器失效的解决方法： 主线程的 RunLoop 里有两个预置的 Mode：kCFRunLoopDefaultMode 和 UITrackingRunLoopMode。这两个 Mode 都已经被标记为 “Commoc” 属性。Default Mode 是 App 平时所处的状态，UITrackingRunLoopMode 是追踪 ScrollView 滑动时的状态（UITextView 的滑动也算）。当你创建一个 Timer 并加到 DefaultMode 时，Timer 会得到重复回调，但此时滑动一个 ScrollView 时，RunLoop 会将 mode 切换为 UITrackingRunLoopMode，这时 Timer 就不会被回调，并且也不会影响的到滑动操作，因为不同 Mode 之间是互不干扰的。有时你需要一个 Timer，在两个 Mode 中都能得到回调，一种方法就是将这个 Timer 分别加入这两个 Mode。还有一种方式，就是将 Timer 加入到顶层的 RunLoop 的 commonModeItems 中，commonModeItems 被 RunLoop 自动更新到所有具有 “Common” 属性的 Mode 里去。 CFRunLoop 对外暴露的管理 Mode 的接口只有下面 2 个： 12CFRunLoopAddCommonMode(CFRunLoopRef runloop, CFStringRef modeName);CFRunLoopRunInMode(CFStringRef modeName, ...); Mode 暴露的管理 mode item 的接口有下面几个： 123456CFRunLoopAddSource(CFRunLoopRef rl, CFRunLoopSourceRef source, CFStringRef modeName);CFRunLoopAddObserver(CFRunLoopRef rl, CFRunLoopObserverRef observer, CFStringRef modeName);CFRunLoopAddTimer(CFRunLoopRef rl, CFRunLoopTimerRef timer, CFStringRef mode);CFRunLoopRemoveSource(CFRunLoopRef rl, CFRunLoopSourceRef source, CFStringRef modeName);CFRunLoopRemoveObserver(CFRunLoopRef rl, CFRunLoopObserverRef observer,CFStringRef modeName);CFRunLoopRemoveTimer(CFRunLoopRef rl, CFRunLoopTimerRef timer, CFStringRef mode); 你只能通过 mode name 来操作内部的 mode，当你传入一个新的 mode name 但 RunLoop 内部没有对应 mode 时，RunLoop 会自动帮你创建对应的 CFRunLoopModeRef。对于一个 RunLoop 来说，其内部的 mode 只能增加不能删除。 苹果公开提供的 Mode 有两个：kCFRunLoopDefaultMode(NSDefalutRunLoopMode) 和 UITrackingRunLoopMode，你可以用这两个 Mode Name 来操作其对应的 Mode。 同时苹果还提供了一个操作 Common 标记的字符串：kCFRunLoopCommonModes(NSRunLoopCommonModes)，你可以用这个字符串来操作 Common Items，或标记一个 Mode 为 “Common”。使用时注意区分这个字符串和其他 mode name。 所以 RunLoop Mode 是可以自定义创建的。 Input Sources输入源以异步的方式向线程传递事件。事件的来源取决于输入源的类型，通常是两个类别之一： Port-based input sources （基于端口的输入源） Custom input sources （自定义输入源） 基于端口的输入源监听应用程序的 Mach 端口，自定义输入源监听自定义事件源。就 RunLoop 而言，输入源是基于端口的还是自定义的是无关紧要的，两个来源之间的唯一区别就是它们如何发出信号。基于端口的源由内核自动发出信号，但是自定义的源必须从另一个线程手动发送信号。 当创建输入源(input sources)时，会将其分配给 RunLoop 的一个或多个 Mode。不同的 Mode 会影响对这些输入源的监听。大部分情况下你在默认模式(kCFRunLoopDefaultMode)下运行 RunLoop，但你也可以指定自定义的 Mode。如果输入源未处于当前监听的 Mode，则在它生成的任何事件，都将被保留，直到 RunLoop 被指定到正确的 Mode 运行。 Port-Based Sources (基于端口的输入源)Cocoa 和 Core Foundation 提供内置支持，使用与端口相关的对象和函数创建基于端口的输入源。例如，在 Cocoa 中，你根本不必直接创建输入源。你只需要创建一个端口对象并使用 NSPort 提供的方法将该端口添加到 RunLoop 中，port 对象会自动为你创建和配置所需的输入源。 在 Core Foundation 中，你必须手动创建端口和输入源。也就是使用 CFMachPortRef、CFMessagePortRef、CFSocketRef 去创建合适的对象。 Custom Input Sources自定义输入源的创建和使用的例子大家可以去查一下官方文档。 Cocoa Perform Selector Sources除了基于端口的源之外，Cocoa 还定义了一个自定义 input source，允许你在任何线程上执行选择器。与基于端口的 source 类似，perform selector 请求在目标线程上被序列化，从而减少在一个线程上运行多个方法时可能发生的许多同步问题。与基于端口的 source 不同，perform selector 源在执行其 selector 后将其自身从 RunLoop 中移除。 在另一个线程执行选择器时，目标线程必须开启了 RunLoop。对于你自己创建的线程，意味着要显式启动 RunLoop。由于主线程中默认启动了 RunLoop，所以只要应用程序调用 applicationDidFinishLaunching: ，就可以开始在主线程上发出调用。RunLoop 每次通过循环处理所有排队的 perform selector 调用，而不是在每次循环迭代期间处理一个。 关于在其他线程上执行选择器的方法，可以查看官方文档的表3.2。 Timer Sources （定时器源）其实就是 NSTimer，计时器，一个 NSTimer 注册到 RunLoop 之后，RunLoop 会为其重复的时间点注册好事件。不过 RunLoop 为了节省资源，并不会在非常准确的时间点回调这个 Timer，因为 RunLoop 内部是有一个处理逻辑的，这个我们放到下面再讲。 定时器是线程通知自己做事情的一种方式。例如，有一个搜索的功能，我们可以使用计时器，设置一个时间，让用户在开始输入之后经过这个时间后开始搜索，这样我们就可以使用户在开始搜索之前输入尽可能的搜索字符串。 虽然我们设置的时间到了计时器就会发出通知让 RunLoop 去做事情，但它并不会真正的实时去处理。与输入源类似，计时器与 RunLoop 的 Mode 相关联。比如你添加定时器到 kCFRunLoopDefaultMode 中，如果此时你的 Mode 是 UITrackingRunLoopMode，那么这个计时器是不会被触发的。除非你切换 Mode 为 kCFRunLoopDefaultMode。如果 Timer 设置的时间到了，该执行 Timer 对应的事件了，但是此时 RunLoop 还在忙着处理其他的事情，那么 Timer 会等到 RunLoop 执行完其他事情再执行。如果线程中的 RunLoop 根本没有被启动，那么 Timer 永远不会被触发。 你可以设置计时器只触发一次或者重复触发，当你设置为重复触发的时候，计时器会按照你原来设置的间隔去不断的触发事件，而不是按照实际触发事件的间隔。比如说你在 11:00 的时候，设置了每隔 10 分钟，触发一次计时器事件，也就是 11:10、11:20、11:30…如果由于某些原因，本来应该在 11:10 分触发的事件，被推迟到了 11:15 才触发，这时虽然你设置的时间间隔是 10 分钟，好像是应该 11:25 才触发下一次事件，但是其实不是的，还是会在 11:20 分触发下一次时间，然后在 11:30 分触发下下次事件。所以计时器是按照你最开始计划的时间来发出通知的。 Observers（观察者）RunLoop 在内部会处理 Source 事件、Timer 触发的事件、会休眠、会退出等，在这些特定的时期，系统会通过 Observer 来通知开发者，Observer 关联了 RunLoop 的下列时刻： 即将进入 RunLoop 即将触发 Timer 回调 即将触发 Source（非基于 port 的 Source，Source0）回调 RunLoop 即将进入休眠 RunLoop 被唤醒，但在它处理唤醒它的事件之前 RunLoop 退出 与 Timer 类似，Observer 可以一次或重复使用。一次性 Observer 在触发后将其自身从 RunLoop 中移除，你可以在创建 Observer 时指定是运行一次还是重复运行。 RunLoop 内部逻辑 下面是官方文档提到的内部逻辑： 通知 Observer 已经进入了 RunLoop 通知 Observer 即将处理 Timer 通知 Observer 即将处理非基于端口的输入源（即将处理 Source0） 处理那些准备好的非基于端口的输入源（处理 Source0） 如果基于端口的输入源准备就绪并等待处理，请立刻处理该事件。转到第 9 步（处理 Source1） 通知 Observer 线程即将休眠 将线程置于休眠状态，直到发生以下事件之一 事件到达基于端口的输入源（port-based input sources）(也就是 Source0) Timer 到时间执行 外部手动唤醒 为 RunLoop 设定的时间超时 通知 Observer 线程刚被唤醒（还没处理事件） 处理待处理事件 如果是 Timer 事件，处理 Timer 并重新启动循环，跳到第 2 步 如果输入源被触发，处理该事件（文档上是 deliver the event） 如果 RunLoop 被手动唤醒但尚未超时，重新启动循环，跳到第 2 步 因为 Timer 和 Source 的 Observer 通知是在这些事件实际发生之前传递的，因此通知事件与实际事件的时间可能存在差距。如果这些事件之间的时间关系很重要，你可以使用休眠和唤醒休眠通知来帮助你关联实际事件之间的时间。 实际上 RunLoop 其内部就是一个 do-while 循环。当你调用 CFRunLoopRun() 时，线程就会一直停留在这个循环里，直到超时或被手动停止，该函数才会返回。 RunLoop 的底层实现RunLoop 的核心是基于 mach port 的，其进入休眠时调用的函数是 mach_msg()。 Mach 本身提供的 API 非常有限，而且苹果也不鼓励使用 Mach 的 API，但是这些 API 非常基础，如果没有这些 API 的话，其他任何工作都无法实施。在 Mach 中，所有的东西都是通过自己的对象实现的，进程、线程和虚拟内存都被称为 “对象”。和其他架构不同，Mach 的对象间不能直接调用，只能通过消息传递的方式实现对象间的通信。“消息” 是 Mach 中最基础的概念，消息在两个端口（port）之间传递，这就是 Mach 的 IPC（进程间通信）的核心。 为了实现消息的发送和接受，mach_msg() 函数实际上是调用了一个 Mach 陷阱（trap），即函数 mach_msg_trap()，陷阱这个概念在 Mach 中等同于系统调用。当你在用户态调用 mach_msg_trap() 时会触发陷阱机制，切换到内核态。内核态中内核实现的 mach_msg() 函数会完成实际的工作。 也就是你在用户态调用了 mach_msg() 函数，会触发 mach trap，进入由系统调用的 mach_msg() 函数中去执行实际的内容。关于用户态和内核态的概念，不知道的朋友可以百度一下。 RunLoop 的核心就是一个 mach_msg()，RunLoop 调用这个函数去接收消息，如果没有别人发送 port 消息过来，内核会将线程置于等待状态。例如你在模拟器跑起一个 iOS 的 App，然后在 App 静止时点击暂停，你会看到主线程调用栈停留在 mach_msg_trap() 这个地方。 什么时候使用 RunLoop按照官方文档的说法，你唯一需要使用到 RunLoop 的时候是为你的应用程序创建辅助线程(create secondary threads)。 App 的主线程的 RunLoop 是一个至关重要的基础架构，因此，App 框架默认在运行时启动主线程并开启主线程中的 RunLoop。如果是用 Xcode 的模板项目来创建应用程序，那么这些系统都已经帮你做好了，不需要显式调用。 对于辅助线程(secondary threads)，要确定实际情况看是否需要开启 RunLoop，如果需要的话，就自行配置并启动它。在任何情况下，都不应该为一个线程开启 RunLoop。例如，如果使用线程执行某些长时间运行且自定义的任务，则可以避免启动 RunLoop。（我觉得这个说的我有点云里雾里，我贴一下原文） You do not need to start a thread’s run loop in all cases. For example, if you use a thread to perform some long-running and predetermined task, you can probably avoid starting the run loop. Run loops are intended for situations where you want more interactivity with the thread. 在以下的几种情况，需要启动 RunLoop： 使用端口或自定义输入源与其他线程通信 在线程上使用计时器 使用 performSelector 调用其他线程方法的时候 保持线程以执行定期任务 苹果用 RunLoop 实现的功能在开发中我还没直接用到 RunLoop 去做过什么东西，可以做一个常驻线程，但是常驻线程这种东西是有问题的，虽然 AFN2.0 曾经用过，但是那是因为当时苹果的网路请求框架有缺陷。另外一个用到 runloop 的地方可能就是做自动轮播那里，用到了 common mode，其他的方面就很少使用了。所以还是具体来看下苹果对 RunLoop 的应用。 AutoreleasePool 事件响应 手势识别 界面更新 定时器 PerformSelector 关于GCD 关于网络请求 AutoreleasePoolApp 启动后，苹果在主线程 RunLoop 里注册了两个 Observer，其回调都是 _wrapRunLoopWithAutoreleasePoolHandler()。 第一个 Observer 监视的事件是 Entry（即将进入 Loop），其回调内会调用 _objc_autoreleasePoolPush() 创建自动释放池。其 order 是 -2147483647，优先级最高，保证创建释放池发生在其他所有回调之前。 第二个 Observer 监视了两个事件：BeforeWaiting(准备进入休眠) 时调用 _objc_autoreleasePoolPop() 和 _objc_autoreleasePoolPush() 释放旧的池并创建新池。Exit(即将退出 Loop) 时调用 _objc_autoreleasePoolPop() 来释放自动释放池。这个 Observer 的 order 是 2147483647，优先级最低，保证其释放池释放发生在其他所有回调之后。 在主线程执行的代码，通常是写在诸如事件回调、Timer 回调内的。这些回调会被 RunLoop 创建好的 AutoreleasePool 环绕着，所以不会出现内存泄漏，开发者也不必显式创建 Pool 了。 简单列举一下步骤： 即将进入 Loop：创建自动释放池 线程即将休眠：释放自动释放池，创建新的自动释放池 即将退出 Loop：释放自动释放池 事件响应苹果注册了一个 Source1（基于 mach port）用来接收系统事件，其回调函数为 __IOHIDEventSystemClientQueueCallback()。 当一个硬件事件（触摸/锁屏/摇晃等）发生后，首先由 IOKit.framework 生成一个 IOHIDEvent 事件并由 SpringBoard 接收。这个过程的详细情况可以参考这里。SpringBoard 只接收按键（锁屏/静音等）、触摸、加速，接近传感器等几种 Event，随后用 mach port 转发给需要的 App 进程。随后苹果注册的那个 Source1 就会触发回调，并调用 _UIApplicationHandleEventQueue() 进行应用内部的分发。 _UIApplicationHandleEventQueue() 会把 IOHIDEvent 处理并包装成 UIEvent 进行处理或分发，其中包括 UIGesture/处理屏幕旋转/发送给UIWindow 等。通常事件比如 UIButton 的点击、touchesBegin/Move/End/Cancel 事件都是在这个回调中完成的。 步骤： 注册一个 Source1 用于接收系统事件 硬件事件发生 IOKit.framework 生成 IOHIDEvent 事件并由 SpringBoard 接收 SpringBoard 用 mach port 转发给需要的 App 注册的 Source1 触发回调 回调中把 IOHIDEvent 处理并包装成 UIEvent 进行处理或分发 手势识别当上面的 _UIApplicationHandleEventQueue() 识别了一个手势时，其首先会调用 Cancel 将当前的 touchesBegin/Move/End 系列回调打断。随后系统将对应的 UIGestureRecognizer 标记为待处理。 苹果注册了一个 Observer 监测 BeforeWaiting(Loop即将进入休眠) 事件，这个 Observer 的回调函数是 _UIGestureRecognizerUpdateObserver()，其内部会获取所有刚被标记为待处理的 GestureRecognizer，并执行 GestureRecognizer 的回调。 当有 UIGestureRecognizer 的变化（创建/销毁/状态改变）时，这个回调都会进行相应处理。 步骤： 识别到手势 调用 Cancel 将当前 touchesBegin/Move/End 系列回调打断 将对应的 UIGestureRecognizer 标记为待处理 BeforeWaiting 时，在其函数回调内部会获取所有刚被标记为待处理的 GestureRecognizer，并执行 GestureRecognizer 的回调 界面更新当在操作 UI 时，比如改变了 frame、更新了 UIView/CALayer 的层次时，或者手动调用了 UIView/CALayer 的 setNeedsLayout/setNeedsDisplay 方法后，这个 UIView/CALayer 就被标记为待处理，并被提交到一个全局的容器去。 苹果注册了一个 Observer 监听 BeforeWaiting(即将进入休眠) 和 Exit(即将退出Loop) 事件，回调去执行一个很长的函数：_ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv()。这个函数里会遍历所有待处理的 UIView/CALayer 以执行实际的绘制和调整，并更新 UI 界面。 步骤： UI 需要更新 将要更新的 UI 标记为待处理，并提交到一个全局的容器去 BeforeWaiting 和 Exit 时遍历所有待处理的 UI 以执行实际的绘制和调整，并更新 UI 界面 定时器NSTimer 其实就是 CFRunLoopTimeRef，他们之间是 toll-free bridged 的。一个 NSTimer 注册到 RunLoop 后，RunLoop 会为其重复的时间点注册好事件。例如 10:00，10:10，10:20 这几个时间点。RunLoop 为了节省资源，并不会非常准确的时间点回调这个 Timer。Timer 有个属性叫做 Tolerance(宽容度)，标示了当时间点到后，容许有多少最大误差。 如果某个时间点被错过了，例如执行了一个很长的任务，则那个时间点的回调也会跳过去，不会延后执行。就比如等公交，如果 10:10 时我忙着玩手机错过了那个点的公交，那我只能等 10:20 这一趟了。 CADisplayLink 是一个和屏幕刷新率一致的定时器（但实际实现原理更复杂，和 NSTimer 并不一样，其内部实际是操作了一个 Source）。如果在两次屏幕刷新之间执行了一个长任务，那其中就会有一帧被跳过去（和 NSTimer 类似），造成界面卡顿的感觉。在快速滑动 TableView 时，即使一帧的卡顿也会让用户有所察觉。Facebook 开源的 AsyncDisplayKit 就是为了解决界面卡顿的问题，其内部也用到了 RunLoop（模仿了 iOS 界面更新的过程）。 PerformSelector当调用 NSObject 的 performSelector:afterDelay: 后，实际上其内部会创建一个 Timer 并添加到当前线程的 RunLoop 中。所以如果当前线程没有 RunLoop，则这个方法会失效。 关于 GCD当调用 dispatch_async(dispatch_get_main_queue(), block) 时，libDispatch 会向主线程的 RunLoop 发送消息，RunLoop 会被唤醒，并从消息中取得这个 block，并在回调 __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__() 里执行这个 block。但这个逻辑仅限于 dispatch 到主线程，dispatch 到其他线程仍然是由 libDispatch 处理的。 关于网络请求iOS 关于网络请求的接口自下至上的层次： 1234CFSocketCFNetwork -&gt;ASIHttpRequestNSURLConnection -&gt;AFNetworkingNSURLSession -&gt;AFNetworking2, Alamofire CFSocket 是最底层的接口，只负责 socket 通信 CFNetwork 是基于 CFSocket 等接口的上层封装 NSURLConnection 是基于 CFNetwork 的更高层的封装，提供面向对象的接口 NSURLSession 是 iOS7 中新增的接口，表面上和 NSURLConnection 并列的，但底层仍然用到了 NSURLConnection 的部分功能（比如 com.apple.NSURLConnectionLoader 线程） 下面主要介绍下 NSURLConnection 的工作过程。 通常使用 NSURLConnection 时，你会传入一个 Delegate，当调用了 [connection start] 后，这个 Delegate 就会不停收到事件回调。实际上，strat 这个函数的内部会获取 CurrentRunLoop，然后在其中的 DefaultMode 添加 4 个 Source0（即需要手动触发的 Source）。CFMultiplexerSource 是负责各种 Delegate 回调的，CFHTTPCookieStorage 是处理各种 Cookie 的。 当开始网络传输时，我们可以看到 NSURLConnection 创建了两个新线程：com.apple.NSURLConnectionLoader 和 com.apple.CFSocket.private。其中 CFSocket 线程是处理底层 socket 连接的。NSURLConnectionLoader 这个线程内部会使用 RunLoop 来接受底层 socket 事件，并通过之前添加的 Source0 通知到上层的 delegate。 NSURLConnectionLoader 中的 RunLoop 通过一些基于 mach port 的 Source 接收来自底层 CFSocket 的通知。当收到通知后，其会在合适的时机向 CFMultiplexerSource 等 Source0 发送通知，同时唤醒 Delegate 线程的 RunLoop 对 Delegate 执行实际的回调。 步骤： 网络开始传输 NSURLConnection 创建两个新线程，com.apple.CFSocket.private 处理 socket 连接，com.aoole.NSURLConnectionLoader 内部使用 RunLoop 来接受底层 socket 事件 socket 有事件发出，NSURLConnectionLoader 通过 Source1 接收到这个通知 NSURLConnectionLoader 在合适的时机向 CFMultiplexerSource、CFHTTPCookieStorage 等 Source0 发送通知，同时唤醒 Delegate 线程的 RunLoop 让其来处理这些通知 CFMultiplexerSource 会在 Delegate 线程的 RunLoop 对 Delegate 执行实际的回调 总结RunLoop 是一个让线程能随时处理事件但并不退出的机制。这种模型通常被称为 Event Loop，实现这种模型的关键点在于：如何管理事件/消息，如何让线程在没有处理消息时休眠以避免资源占用、在有消息到来时立刻被唤醒。 所以，RunLoop 实际上就是一个对象，这个对象管理了其需要处理的事件和消息，并提供了一个入口函数来执行上面 Event Loop 的逻辑。线程执行了这个函数后，就会一直处于函数内部 “接受消息-&gt;等待-&gt;处理” 的循环中，直到这个循环结束（比如传入 quit 的消息），函数返回。 说 RunLoop 就绕不开线程，RunLoop 与线程的关系： RunLoop 与线程一一对应，它们的关系呗保存在一个全局的 Dictionary 中 RunLoop 是懒加载的，你不主动获取，那它一直都不会有 RunLoop 的销毁发生在线程结束时 主线程的 RunLoop 是默认开启的 一个 RunLoop 包含若干个 Mode，每个 Mode 包含若干个 Source/Timer/Observer，Source/Timer/Observer 被统称为 Mode Item。不同 Mode 之间互不干扰。 在 Core Foundation 里面关于 RunLoop 的 5 个类： CFRunLoopRef CFRunLoopModeRef CFRunLoopSourceRef CFRunLoopTimerRef CFRunLoopObserver Mode 系统默认注册了 5 个 Mode： kCFRunLoopDefaultMode：App 的默认 Mode UITrackingRunLoopMode：界面跟踪 Mode，用于 ScrollView 追踪触摸滑动 UIInitializationRunLoopMode：在刚启动 App 时进入的第一个 Mode GSEventReceiveRunLoopMode：接受系统事件的内部 Mode，通常用不到 kCFRunLoopCommonModes：这是一个占位的 Mode，没有实际作用 Source 主要分两种类型： Source0：不能主动触发事件 Source1：能主动唤醒 RunLoop 的线程 具体的类型： Port-Based Sources：基于端口的源 Custom Input Sources：自定义输入源 Cocoa Perform Selector Sources：Cocoa 定义的一个自定义输入源 Timer 基于时间的触发器，提前在 RunLoop 中注册好事件，时间点到达时，RunLoop 将被唤醒以执行事件。受限于 RunLoop 的内部逻辑，计时器并不十分准确。 Observer 观察者，每个 Observer 都包含了一个回调（函数指针）。 可观测的时间点： kCFRunLoopEntry : 即将进入 Loop kCFRunLoopBeforeTimers : 即将处理 Timer kCFRunLoopBeforeSources : 即将处理 Source kCFRunLoopBeforeWaiting : 即将进入休眠 kCFRunLoopAfterWaiting : 刚从休眠中唤醒 kCFRunLoopExit : 即将退出 Loop]]></content>
      <categories>
        <category>iOS概念攻坚之路</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>Objective-c</tag>
        <tag>Swift</tag>
      </tags>
  </entry>
</search>
